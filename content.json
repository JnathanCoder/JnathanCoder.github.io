[{"title":"移动端真机调试 spy-debugger","date":"2019-07-15T08:53:26.000Z","path":"2019/07/15/spy-debugger/","text":"关于spy-debugger一站式页面调试、抓包工具。远程调试任何手机浏览器页面，任何手机移动端webview（如：微信，HybridApp等）。支持HTTP/HTTPS，无需USB连接设备。 特性1、页面调试＋抓包2、操作简单，无需USB连接设备3、支持HTTPS。4、spy-debugger内部集成了weinre、node-mitmproxy、AnyProxy。5、自动忽略原生App发起的https请求，只拦截webview发起的https请求。对使用了SSL pinning技术的原生App不造成任何影响。6、可以配合其它代理工具一起使用(默认使用AnyProxy) (设置外部代理) 安装12[sudo] npm install spy-debugger -g` 三分钟上手第一步：手机和PC保持在同一网络下（比如同时连到一个Wi-Fi下）第二步：命令行输入spy-debugger，按命令行提示用浏览器打开相应地址。第三步：设置手机的HTTP代理，代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)。 Android设置代理步骤：设置 - WLAN - 长按选中网络 - 修改网络 - 高级 - 代理设置 - 手动iOS设置代理步骤：设置 - 无线局域网 - 选中网络 - HTTP代理手动 第五步：用手机浏览器访问你要调试的页面即可。 效果截图 自定义选项端口(默认端口9888)1spy-debugger -p 9999 设置外部代理（默认使用AnyProxy）1spy-debugger -e http://127.0.0.1:8888 设置页面内容为可编辑模式（默认false）1spy-debugger -w true 该功能使页面内容修改更加直观方便。内部实现原理：在需要调试的页面内注入代码：document.body.contentEditable=true。暂不支持使用了iscroll框架的页面。 是否允许weinre监控iframe加载的页面(默认false)1spy-debugger -i true 是否只拦截浏览器发起的https请求（默认true）1spy-debugger -b false 是否允许HTTP缓存(默认false)1spy-debugger -c true","comments":true,"tags":[]},{"title":"知识点","date":"2019-06-06T08:48:44.000Z","path":"2019/06/06/brief-info/","text":"1. 一些js插件为什么以;开头因为js代码允许在结束的时候不添加;, 所以两个js文件在合并拼接的的时候可能出错。 12345678// a.js// 末尾没有添加;符号var a = 'test'// b.js(function()&#123; // do something&#125;)(); 以上两个文件进行合并压缩的时候就可能变为： 123var a = 'test'(function()&#123;&#125;)();// 这样会报错： TypeError: 'test' is not a function 2. 使用闭包定义私有属性123456789101112131415161718function Product() &#123; var name; this.setName = function(value) &#123; name = value; &#125;; this.getName = function() &#123; return name; &#125;;&#125;var p = new Product();p.setName(\"test\");console.log(p.name); // 输出undefinedconsole.log(p.getName()); // 输出test 代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。 3. 枚举属性 可枚举性在js中，基本数据类型的原型属性是不可枚举的，比如Object、Array、Number等。 12345// 打印结果为空 Number内置属性是不可枚举的var num = new Number()for (let i in num) &#123; console.log(i, num[i])&#125; propertyIsEnumerable Object.propertyIsEnumerable(prop)prop 需要测试的属性名返回值 用来表示指定的属性名是否可枚举的Boolean 1234567var obj = &#123;&#125;obj.test = 'Jnathan'var arr = [23, 67]obj.propertyIsEnumerable('test') // truearr.propertyIsEnumerable(0) // truearr.propertyIsEnumerable(1) // true hasOwnProperty Object.hasOwnProperty(prop)prop 需要测试的属性名返回值 用来表示指定的属性名是否在对象中的Boolean 1234567var obj = &#123;&#125;obj.x = 'Jnathan'obj.y = function() &#123;&#125;obj.hasOwnProperty('x') // trueobj.hasOwnProperty('y') // true 方法也属于属性obj.hasOwnProperty('z') // false 属性不存在obj.hasOwnProperty('toString') // false toString是继承的Object中的属性，obj自身属性中不包含 123456789101112function Person() &#123; this.name = 'Jnathan'&#125;Person.prototype = &#123; constructor: Person, job: 'student',&#125;var Jnathan = new Person()Object.defineProperty(Jnathan, \"gender\", &#123; value: 'female', enumerable: false&#125;) 以上， 用defineProperty为对象Jnathan定义了一个名为gender的不可枚举属性 枚举 for…in 12345678for (let item in Jnathan) &#123; console.log('Jnathan.' + item + ' = ' + Jnathan[item])&#125;// Jnathan.name = Jnathan// Jnathan.constructor = function Person() &#123;// this.name = 'Jnathan'// &#125;// Jnathan.job = student 枚举 Object.keys() 12Object.keys(Jnathan)// [\"name\"] 枚举 JSON.stringify() 12JSON.stringify(Jnathan)// \"&#123;\"name\":\"Jnathan\"&#125;\" 根据现象有以下总结Object.keys() 只能返回对象本身具有的可枚举属性JSON.stringify() 只能返回对象本身的可枚举属性，并序列化为JSON字符串 Object.defineProperty() 参数：Object.defineProperty(object, propertyname, descriptor)object 必需。 要在其上添加或修改属性的对象。 这可能是一个本机 JavaScript 对象（即用户定义的对象或内置对象）或 DOM 对象。propertyname 必需。 一个包含属性名称的字符串。descriptor 必需。 属性描述符。 它可以针对数据属性或访问器属性。返回值：已修改对象 当对象不具有指定的属性名称时，向对象添加新属性。当对象已具有指定的属性名称时，修改现有属性的特性。 12345678910var obj = &#123;&#125;Object.defineProperty(obj, \"newDataProperty\", &#123; value: 101, writable: false, enumerable: false, configurable: true&#125;);obj.newDataProperty = 102console.log(obj.newDataProperty) // 101 whiteable为false 只读，不能修改 Object.getOwnPropertyNames 由于obj的属性newDataProperty是不可枚举的，使用for…in不能找到newDataProperty属性 123for (let item in obj) &#123; console.log(item, obj[item]) // 无输出&#125; 此时可以使用Object.getOwnPropertyNames来遍历 12345var names = Object.getOwnPropertyNames(obj)for (let i = 0; i &lt; names.e]length; names++) &#123; console.log(names, i, names[i])&#125;// [\"newDataProperty\"] 0 newDataProperty 12345678910111213141516171819var obj = &#123;&#125;Object.defineProperty(obj, \"newAccessorProperty\", &#123; set: function (x) &#123; console.log(\"in property set accessor\"); this.newaccpropvalue = x; &#125;, get: function () &#123; console.log(\"in property get accessor\"); return this.newaccpropvalue; &#125;, enumerable: true, configurable: true&#125;);obj.newAccessorProperty = 30console.log(\"Property value: \" + obj.newAccessorProperty)// in property set accessor// in property get accessor// Property value: 30 修改DOM上的属性 12Object.getOwnPropertyDescriptor(Element.prototype, \"querySelector\")// &#123;value: ƒ, writable: true, enumerable: true, configurable: true&#125; 1234567891011var descriptor = Object.getOwnPropertyDescriptor(Element.prototype, \"querySelector\")descriptor.value = \"query\"descriptor.writable = falseObject.defineProperty(Element.prototype, \"querySelector\", descriptor)var elem = document.getElementById(\"div\")elem.querySelector = \"anotherQuery\" // whitable 为false 更改不生效console.log(elem.querySelector) // query","comments":true,"tags":[]},{"title":"日志内容【二】","date":"2019-05-26T06:08:31.000Z","path":"2019/05/26/multiple-diary2/","text":"1. substr() 和 substring() substr stringObject.substr(startIndex[, length]) 12345678var str = ‘abcdefg'str.substr(2) // ‘cdefg’str.substr(-1) =&gt; str.substr(6) // ‘fg’str.substr(6) // ‘'str.substr(2,2) // ‘cd’str.substr(2,7) // ‘cdefg’str.substr(2,-1) // '' substring stringObject.substring(startIndex[, stop]) 注意stop的含义 1234567var str = ‘abcdefg'str.substring(2) // ‘cdefg’str.substring(2,4) // ‘cd’str.substring(2,9) // ‘cdefg’str.substring(-2) =&gt; str.substring(0) // ‘abcdefg’str.substring(2,-4) =&gt; str.substring(2,0) =&gt; str.substring(0,2) // ‘ab' 2. slice() 和 splice() slice stringObject.slice(startIndex[, stop])arrayObject.slice(startIndex[, stop])stop 缺省时 默认一直到最后 12345678910111213var str = ‘abcdefg’str.slice(2) // ‘cdefg'str.slice(0) // ‘abcdefg’str.slice(-2) =&gt; str.slice(5) // ‘fg’str.slice(8) // ‘’ 空串 str.slice(2,4) // ‘cd’str.slice(2,6) // ‘cdef’str.slice(2,18) // ‘cdefg’str.slice(4,2) // ‘’ 空串str.slice(4,-1) =&gt; str.slice(4,6) // ‘ef’// 数组方法类似 splice arrayObject.splice(startIndex, length[, item1, item2…])splice操作会改变原数组 返回被移除的元素数组 12345678var arr = [‘a’,’b’,’c’,’d’,’e’,’f’,’g’]arr.splice(2,0) // 空数组 arr = [‘a’,’b’,’c’,’d’,’e’,’f’,’g’]arr.splice(2,8) // arr = [‘a’, ‘b’, ‘c']arr.splice(2,-5) // 返回arr arr没有变化arr.splice(8,2) // 返回arr arr没有变化arr.splice(2,2,'11',’22') // 返回[‘a’, ‘b’, ’11’, ’22’, ‘e’, ‘f’, ‘g’] arr = [‘c’, ‘d'] 3. 检测数据类型 typeof typeof 是解释器内部实现，根据 ECMA-262 规定的几种类型的值来返回类型名称。但是 typeof 的应用场景非常有限，基本上只能判断出来使用字面量方式赋值的基本数据类型。 12345678910typeof 23 // numbertypeof '124' // stringtypeof true // booleantypeof undefined // undefinedtypeof &#123;&#125; // objecttypeof null // objecttypeof [1, 3, 8] // objecttypeof function fn () &#123;&#125; // functiontypeof (new Number(33)) // objecttypeof (new String('hello')) // object 从上面例子可以看出， typeof 检测出来的类型不够准确，具有相当大的局限性。 instanceof instance 检测类型的原理大致为: 判断左边的对象的隐式原型 proto 是否和右边对象的显式原型 prototype 相等。 很像 new 操作，这样就可以判断指定的某个对象是否为某个构造函数的实例。 instance 的局限性应该是不能检测基本数据类型。另外一点，不同 window 或者 iframe 之间对象类型检测不能使用 instanceof 来检测。 1234567'123' instance String // falseNumber instanceof Number // truenew String('hello') instance String // truenew Number(33) instance Number // true Object.prototype.toString 1234567891011121314151617Object.prototype.toString.call(33) // [object Number]Object.prototype.toString.call('hello') // [object String]Object.prototype.toString.call([]) // [object Array]Object.prototype.toString.call(&#123;&#125;) // [object Object]Object.prototype.toString.call(true) // [object Boolean]Object.prototype.toString.call(null) // [object null]Object.prototype.toString.call(undefined) // [object undefined]Object.prototype.toString.call(function fn () &#123;&#125;) // [object Function]Object.prototype.toString.call(new Number(33)) // [object Number] constructor constructor 属性返回对创建此对象的数组函数的引用。constructor 不能检测出null和undefined两种，会报错。 1234567891011121314151617181920(33).constructor == Number // true('hello'.constructor == String // true([]).constructor == Array // true(&#123;&#125;).constructor == Object // true(true).constructor == Boolean // true(null).constructor == null // TypeError: Cannot read property 'constructor' of null(undefined).constructor == undefined // TypeError: Cannot read property 'constructor' of undefinedvar fn = function () &#123;&#125;fn.constructor == Function // truevar number = new Number(66)number.constructor == Number // truenumber.constructor == Object // false 我是分割线 Array.isArray() 4. ES5 Array Function forEach Array.forEach(callbackFn[, thisObj])callbackFn (value, index, arr)thisObj 默认为 window 123[1, 2, 5, 8].forEach( function (ele, index, arr) &#123; console.log(ele, index, arr)&#125;) map Array.map(callbackFn[, thisObj])callbackFn (value, index, arr) 123[1, 2, 5, 8].map(function (ele, index, arr) &#123; return ele * index // [0, 2, 10, 24]&#125;) filter Array.filter(callbackFn[, thisObj])callbackFn (value, index, arr), 需要返回 Boolean 值 1234567[0, 2, 5, 8].filter(function (ele, index, arr) &#123; return ele // [2, 5, 8]&#125;)[0, 2, 5, 1].filter(function (ele, index, arr) &#123; return ele &lt;= index // [0, 1]&#125;) some Array.some(callbackFn[, thisObj])callbackFn (value, index, arr) 123[1, 2, 5, 8].some(function (ele, index, arr) &#123; return ele &gt; 5 // true (8 &gt; 5)&#125;) every Array.every(callbackFn[, thisObj])callbackFn (value, index, arr) 123[1, 2, 5, 8].every(function (ele, index, arr) &#123; return ele &gt; 5 // false (1, 2, 5 均不大于5)&#125;) indexOf Array.indexof(searchEle[, fromIndex])第一个出现的 searchEle 的索引位置searchEle 要查找的元素fromIndex 开始查找的索引位置，缺省或不符合规范时为 0 1234[1, 2, 5, 8].indexOf(2) // 1[1, 2, 5, 8].indexOf(2, '0') // 1[1, 2, 5, 8].indexOf(2, 'f') =&gt; [1, 2, 5, 8].indexOf(2, 0) // 1[1, 2, 5, 8].indexOf(2, 2) // -1 lastIndexOf Array.lastIndexOf(searchEle[, fromIndex])与 indexOf 不同在于此方法是从后面元素开始查找的searchEle 要查找的元素fromIndex 开始查找的索引位置，缺省时或大于等于 Array.length 为 Array.length - 1 123456[1, 2, 5, 8, 5].lastIndexOf(5) // 4[1, 2, 5, 8, 5].lastIndexOf(5, 4) // 4[1, 2, 5, 8, 5].lastIndexOf(5, 8) =&gt; [1, 2, 5, 8, 5].lastIndexOf(5, 4) // 4[1, 2, 5, 8, 5].lastIndexOf(5, 'f') // -1[1, 2, 5, 8, 5].lastIndexOf(5, 3) // 2[1, 2, 5, 8, 5].lastIndexOf(5, 1) // -1 reduce Array.reduce(callbackFn[, initValue])callbackFn(previous, current, index, arr)previous 前一次迭代计算出来的值current 当前迭代的值initValue 初始值, 未指定时取数组的第一个元素 123[1, 2, 5, 8].reduce(function (preV, curV, index, arr) &#123; return preV + curV&#125;, 10) // 26 123456789101112131415// 梳理一下计算过程：// 初始化的时候preV = initValue = 10, curV = 1, index = 0// 第一次计算preV = 10 + 1 = 11, curV = 2, index = 1// 第二次计算preV = 11 + 2 = 13, curV = 5, index = 2// 第三次计算preV = 13 + 5 = 18, curV = 8, index = 3// 第四次计算preV = 18 + 8 = 26, curV = undefined (退出) reduceRight 和 reduceRight 用法基本一致，不过是从数组后面开始迭代的Array.reduceRight(callbackFn[, initValue])callbackFn(previous, current, index, arr)previous 前一次迭代计算出来的值current 当前迭代的值 123456[1, 2, 5, 8].reduceRight(function (preV, curV, index, arr) &#123; if (index == 0) &#123; return preV - curV &#125; return preV + curV&#125;, 10) // 24 123456789101112131415// 梳理一下计算过程：// 初始化的时候preV = initValue = 10, curV = 8, index = 3// 第一次计算preV = 10 + 8 = 18, curV = 5, index = 2// 第二次计算preV = 18 + 5 = 23, curV = 2, index = 1// 第三次计算preV = 23 + 2 = 25, curV = 1, index = 0// 第四次计算preV = 25 - 1 = 24, curV = undefined (退出) 参考文章","comments":true,"tags":[]},{"title":"webpack-study","date":"2019-05-23T07:29:00.000Z","path":"2019/05/23/webpack-study/","text":"webpack-dev-server12345678910111213141516171819var devMiddleware = require('webpack-dev-middleware')(compiler, &#123; publicPath: webpackConfig.output.publicPath, hot: true, stats: &#123; colors: true, chunks: false &#125;&#125;)// use expressapp.use(devMiddleware)app.listen(port, host, function (err) &#123; if (err) &#123; console.log(err) return &#125; console.log('Listening at ' + host + ':' + port + '\\n')&#125;) CommonsChunkPlugin123456789101112131415161718192021// webpack.config.jsvar webpack = require(‘webpack’)entry: &#123; vendor: ['jquery', 'lodash'], vuecore: './vuecore.js'&#125;, plugins: [ // new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.bundle.js'), // new webpack.optimize.CommonsChunkPlugin(&#123; // name: 'vuecore', // filename: 'vuecore.js' // &#125;), // Error: CommonsChunkPlugins: While running in normal mode its not allowed to use a non-entry chunk (vuecore) // doing this instaed new webpack.optimize.CommonsChunkPlugin(&#123; names: ['vuecore','vendor'] &#125;), new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.bundle.js')]","comments":true,"tags":[{"name":"webpack","slug":"webpack","permalink":"https://JnathanCoder.github.io/tags/webpack/"}]},{"title":"日志内容【一】","date":"2019-05-22T09:43:43.000Z","path":"2019/05/22/multiple-diary/","text":"1. setTimeout中方法体添加引号与不添加引号的区别 添加引号的情况，调用的函数是全局范围的。未添加引号的情况，调用的是局部范围的。 1234567891011121314151617var testFn = function () &#123; console.info('hello from global')&#125;var fn = function () &#123; var testFn = function () &#123; console.info('hello fron inner') &#125; setTimeout('testFn()', 1000) // hello form global setTimeout(testFn, 1000) // hello from inner // 在fn()函数内部没有定义testFn的时候，会向上寻找testFn，这里找到了全局函数，执行效果： setTimeout(testFn, 1000) // hello from global&#125;fn() 2. AMD/CMD规范 common.jscommon.js 运行在服务器端，因为模块就在磁盘上，所以加载时间几乎可以忽略不计，属于同步加载。 [典型代表 node.js]AMD与CMD都属于异步加载，运行在浏览器端。AMD 推崇依赖前置，定义模块的时候就需要申明需要依赖的模块 [典型代表 require.js]CMD 推崇依赖就近，需要用到的时候才去require相关模块 [典型代表 sea.js] 3. stopPropagation() 以及 stopImmediatePropagation()stopImmediatePropagation 用于阻止冒泡，在执行完当前元素上的事件处理程序之后，停止当前元素以及后续元素的事件处理程序 stopPropagation 同样也是用于阻止冒泡，在执行完绑定到当前元素上的所有事件处理程序之后，停止后续元素的事件处理程序 同一个元素用on绑定多次同样事件时（例如click），最后一次会覆盖之前的事件，不会执行前面。而用addEventListener绑定多次同样事件时，都会执行。 12345&lt;div id=\"large\" style=\"width: 150px; height: 150px; background: orange\"&gt; &lt;div id=\"middle\" style=\"width: 100px; height: 100px; background: cadetblue\"&gt; &lt;div id=\"small\" style=\"width: 50px; height:50px; background: coral\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546(function()&#123; var large = document.getElementById('large') var middle = document.getElementById('middle') var small = document.getElementById('small') large.addEventListener('click', function()&#123; alert('large div is clicked') &#125;) middle.addEventListener('click', function()&#123; alert('middle div is clicked') &#125;) // 第一种情况： 点击small时，会依次弹出三个窗口，这是因为向上冒泡产生的 small.addEventListener('click', function()&#123; alert('small div is clicked') &#125;) // 第二种情况： 点击small时，会弹出四个窗口 // small.addEventListener('click', function()&#123; // alert('small-1 is clicked') // &#125;) // small.addEventListener('click', function()&#123; // alert('small-2 is clicked') // &#125;) // 第三种情况，添加stopPropagation： 点击small时，会弹出两个窗口 // small-1 is clicked small-2 is clicked // small.addEventListener('click', function(event)&#123; // alert('small-1 is clicked') // event.stopPropagation() // &#125;) // small.addEventListener('click', function()&#123; // alert('small-2 is clicked') // &#125;) // 第四种情况，添加stopImmediatePropagation： 点击small时，会弹出一个窗口 // small-1 is clicked // 能够很明显看到与stopPropagation的区别，调用stopImmediatePropagation之后，第二个定义的click事件也被取消而不被执行了。 // small.addEventListener('click', function(event)&#123; // alert('small-1 is clicked') // event.stopImmediatePropagation() // &#125;) // small.addEventListener('click', function()&#123; // alert('small-2 is clicked') // &#125;)&#125;)() (function(){ var large = document.getElementById('large') var middle = document.getElementById('middle') var small = document.getElementById('small') large.addEventListener('click', function(){ alert('large div is clicked') }) middle.addEventListener('click', function(){ alert('middle div is clicked') }) // 第一种情况： 点击small时，会依次弹出三个窗口，这是因为向上冒泡产生的 small.addEventListener('click', function(){ alert('small div is clicked') }) // 第二种情况： 点击small时，会弹出四个窗口 // small.addEventListener('click', function(){ // alert('small-1 is clicked') // }) // small.addEventListener('click', function(){ // alert('small-2 is clicked') // }) // 第三种情况，添加stopPropagation： 点击small时，会弹出两个窗口 // small-1 is clicked small-2 is clicked // small.addEventListener('click', function(event){ // alert('small-1 is clicked') // event.stopPropagation() // }) // small.addEventListener('click', function(){ // alert('small-2 is clicked') // }) // 第四种情况，添加stopImmediatePropagation： 点击small时，会弹出一个窗口 // small-1 is clicked // 能够很明显看到与stopPropagation的区别，调用stopImmediatePropagation之后，第二个定义的click事件也被取消而不被执行了。 // small.addEventListener('click', function(event){ // alert('small-1 is clicked') // event.stopImmediatePropagation() // }) // small.addEventListener('click', function(){ // alert('small-2 is clicked') // }) })() 4. js事件中的三个阶段三个阶段分别为捕获阶段 目标阶段 冒泡阶段element.addEventListener(type, fn[, useCapture])useCapture - 指定事件句柄在捕获阶段或者冒泡阶段执行， 默认false(事件句柄在冒泡阶段执行)，设置为true(事件句柄在捕获阶段执行)。 捕获阶段 目标阶段 冒泡阶段 5. 常见的前端性能优化手段 css sprites（雪碧图） 避免使用css表达式 css样式表放在页面顶部，脚本放在页面底部 内联图片和脚本使用data:URL（base64编码）模式直接包含在页面中，无需进行http请求，缺点：ie不支持，图片太大不适用，使用base64会增加页面体积，浏览器不会缓存 使用内容分发网络CDN 开启GZIP压缩，启用负载均衡 开启keep alive减少与服务器链接次数 缺点：使服务器负载增大，也更容易遭受攻击 精简压缩代码 uglifyjs 避免重定向 常见的301 302 配置e-tags 和 expires头 使用缓存 按需加载资源 6. parseInt() 以及 parseFloat() parseInt(string[, radix]) string如果以‘ox’或者’oX’开头，将以16进制进行解析 radix 要解析的数字基数，介于2-36之间 如果不给值或者为0，则按照基数为10来计算 如果小于2或者大于36，则返回NaN 开头和结尾的空格是允许的 如果字符串的第一个字符不能转换成对应的数字，将返回NaN 12345678910111213141516171819parseInt('0x12') // 17parseInt('0x12', 2) // 0 =&gt; parseInt('0', 2)parseInt('0x12', 10) // 0 =&gt; parseInt('0', 16)parseInt('8') // =&gt; parseInt('8', 0) =&gt; parseInt('8', 10) // 8parseInt('8', 1) // NaNparseInt('8', 37) // NaNparseInt('a23') // NaNparseInt('2a3') // 2parseInt(' 23') // 23parseInt(' 23 ') // 23parseInt(' 2 3 ') // 2parseInt('11', 2) // 3parseInt(11, 2) // 3parseInt('1100', 2) // 12parseInt('21', 2) // NaN 2超出了2进制最大值1，并且是第一个字符parseInt('12', 2) // 1 2同样超出了2进制最大值1，但是第一个字符可以转换成二进制parseInt('66', 8) // 6*8^1 + 6*8^0 = 48 + 6 = 54parseInt('12', 16) // 1*16^1 + 2*16^0 = 16 + 2 = 18[0, 1, 2, 3].map(parseInt) // [parseInt(0, 0), parseInt(1, 1), parseInt(2, 2), parseInt(3, 3)] =&gt; [0, NaN, NaN, NaN] parseFloat() parseInt(string[, radix]) 这里语法待修改 开头和结尾的空格是允许的 如果字符串的第一个字符不能转换成对应的数字，将返回NaN 如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符 7. charAt()、charCodeAt() 和 fromCharCode() charAt() String.charAt(index) 返回字符串中指定位置的字符, 索引值 index &lt; 0 或超出了范围则返回一个空字符串 123'abc'.charAt(1) // 'b''abc'.charAt(-2) // '''abc'.charAt(5) // '' charCodeAt() String.charCodeAt(index) 返回字符串中指定位置的字符的 unicode 数值 [0, 1114111] 开头的 128 个 unicode 编码单元和 ASCII 字符编码一样 索引值 index &lt; 0 或超出了范围则返回一个 NaN, 大于 255 的是中文 12345'AabcdD'.charCodeAt(0) // 65'AabcdD'.charCodeAt(1) // 97'AabcdD'.charCodeAt(-1) // NaN'AabcdD'.charCodeAt(8) // NaN'中国'.charCodeAt(1) // 22269 fromCharCode() String.fromCharCode(num1, num2, num3, …) 根据指定的 unicode 编码中的序号值来返回字符串 1String.fromCharCode(65, 66, 97) // 'ABa' 8. 原生ajax12345678910var xhr = new XMLHttpRequest()// 请求方式 请求路径 是否异步发送请求xhr.open('GET', 'http://www.jnathan.cn/jnathan/effect/authKit.js', true)xhr.send('hello world') xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // alert(xhr.responseText) &#125;&#125; 9. 有一个长度为n的数组，假定全部为整数，其中有且仅有一个数出现了奇数次，其他的数字都出现偶数次，找出出现了奇数次的那个数字。 时间复杂度为O(n) 空间复杂度O(1)利用了n ^ n = 0, n ^ 0 = n两个等式的原理。循环对数组数字进行异或计算，即 0 ^ arr[0] ^ arr[1] ^ ... ^ arr[n - 1] ，异或计算满足交换律原则，如果数组元素出现了相同的情况，可以移动到一起先进行计算，如果出现了偶数次，其结果为 0，出现了奇数次的数其结果为该数字，所以表达式最后得出来的结果即为数组所有出现了奇数次元素的异或操作的结果。比如：[1,2,2,3,4,4]进行异或操作得到的结果是 1 ^ 3 = 2 ，特殊情况下（只有一个数字出现了奇数次），那么最后的结果就是出现了奇数次的那个数字！！ 123456789function fn7 (arr) &#123; var oddTimesNumber = 0 for (let i in arr) &#123; oddTimesNumber = oddTimesNumber ^ arr[i] &#125; return oddTimesNumber&#125;fn7([1,2,3,4,5,4,4,3,2,1,1,1]) // 3 10. 递归求1-10的和123456789101112function getSum(nextArr, curSum = 0) &#123; var sum = nextArr[0] + curSum if (nextArr.length == 1) &#123; return sum &#125; else &#123; return getSum(nextArr.slice(1), sum) &#125;&#125;getSum([1,2,3,4,5,6,7,8,9,10]) 11. 去除数组重复元素 直接双层循环比较 123456789101112131415161718192021222324function unique (arr) &#123; var result = [] var isRepeat for (var i = 0; i &lt; arr.length; i++) &#123; isRepeat = false // 默认不重复，进行push操作，当判断重复时不操作 for (var j = 0; j &lt; result.length; j++) &#123; if (arr[i] === result[j]) &#123; isRepeat = true break &#125; &#125; if (!isRepeat) &#123; result.push(arr[i]) &#125; &#125; return result&#125;unique([1,1,2,3,4]) 利用indexOf()， 但是indexOf会一直循环到找到目标为止，浪费了时间 12345678910111213function unique (arr) &#123; var result = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (result.indexOf(arr[i]) === -1) &#123; result.push(arr[i]) &#125; &#125; return result&#125;unique([1,1,2,3,4]) 最快的方法 把已经出现过的元素通过下标的形式存入一个Object内。下标的引用的实现原理利用的是哈希算法，要比用indexOf()搜索数组快的多。由于多了一个hash表，占用的内存会更多，空间换时间做法 1234567891011121314function unique (arr) &#123; // hashObj为hash表，result为临时数组 var hashObj = &#123;&#125;, result = [] for (var i = 0; i &lt; arr.length; i++) &#123; // 如果hash表中没有当前项 if (!hashObj[arr[i]]) &#123; // 存入hash表 hashObj[arr[i]] = true // 把当前数组的当前项push到临时数组里面 result.push(arr[i]) &#125; &#125; return result&#125; 折衷方法 时间上比indexOf快，比hash表的方式要慢。先按照从小到大的顺序排序，然后比较相邻的两个值大小 12345678910function unique (arr) &#123; arr.sort() var result = [arr[0]] for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== result[result.length - 1]) &#123; result.push(arr[i]) &#125; &#125; return result&#125; es6的filter()方法 1234567891011121314function unique (arr) &#123; return arr.filter( (value, index) =&gt; &#123; arr.indexOf(value) === index console.log(arr.indexOf(value), index) // 0 0 // 0 1 // 2 2 // 3 3 // 4 4 // 5 5 // 2 6 &#125;)&#125;unique([1,1,2,3,4,5,2]) 12. jquery 里面的 $(document).ready(function(){}) 和 window.onload 的区别 window.onload需要等到页面中包括图片在内的元素全部加载完毕才能执行；ready()是DOM元素绘制结束之后就执行，不用等到加载完毕。 window.onload如果定义了多次，则只会执行一个，后者会覆盖前者； ready()可以同时编写多个，并且都会执行。 window.onload没有简化写法；$(document).ready(function(){})可以简化成$(function(){})。 补充：$(window).load(function(){})和 window.onload()效果一致。 13. 渐进增强与优雅降级 渐进增强 一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再对高级浏览器进行效果、交互的优化，达到更好的体验。 优雅降级 一开始就构建站点的完整功能，然后针对浏览器进行测试和修复。比如一开始使用CSS3的特性构建了一个应用，然后逐步针对各大低级浏览器进行hack使其可以在低版本浏览器上正常浏览。 14. cookies、localStorage和sessionStorage的区别 cookies存在于客户端，始终会在http请求中通过 Request Headers Cookie头携带，即使当前请求不需要使用到cookie；大小一般在4KB，所以只适合保存很小的数据，比如会话标识；cookies在没有设置过期时间（expires）的时候，默认在关闭浏览器之后就会被清除，在有设置过期时间的时候，会一直持续到过期时间有效（即使关闭当前窗口或者关闭浏览器）。 localStorage 和 sessionStorage不会发送数据到服务端，仅在本地保存；也有大小的限制，但一般在5M左右；localStorage一直有效，除非手动清除； sessionStorage只在浏览器关闭之前有效。 另外： localStorage 和 cookies 在同源的浏览器窗口之间是共享的，sessionStorage不共享，因此至少有以下两种方法实现不同页面间的通信： 利用localStorage 123456789// A页面$('#btn').click(function()&#123; localStorage.setItem('name', 'Jnathan')&#125;)// B页面window.addEventListener('storage', function(event)&#123; console.log(event.key + '=' + event.newValue)&#125;) 利用cookie + setInterval() 123456789101112// A页面$('#btn').click(function () &#123; document.cookie = \"name=\" + 'Jnathan'&#125;)// B页面function getKey(key) &#123; return JSON.parse(\"&#123;\\\"\"+ document.cookie.replace(/;\\s+/gim,\"\\\",\\\"\").replace(/=/gim, \"\\\":\\\"\") +\"\\\"&#125;\")[key]; &#125;setInterval(function()&#123; console.log('name:', getKey('name'))&#125;, 1000) 15. new 操作符的四个步骤12var Fn = function() &#123;&#125;var fn = new Fn() 创建一个空对象 1var obj = new Object() 设置obj的原型，将obj的原型指向Fn的原型链 1obj.__proto__ = Fn.prototype 将Fn中的this指向obj,并执行Fn 1var result = Fn.call(obj) 判断Fn的返回值类型。如果是引用类型，则返回这个引用类型的对象；如果是值类型，则返回obj` 12345if (typeof result == 'object') &#123; // 引用类型 fn = result&#125; else &#123; // 值类型 fn = obj&#125; 16. 构造函数实现继承的几种方式1234567function Animal () &#123; this.species = '动物'&#125;function Cat (name, color) &#123; this.name = name this.color = color&#125; 使猫继承动物： call apply 12345678function Cat (name, color) &#123; Animal.apply(this, arguments) this.name = name this.color = color&#125;var cat1 = new Cat('name1', 'color1')alert(cat1.species) // 动物 prototype（其一） 12345678function Cat (name, color) &#123; Animal.apply(this, arguments) this.name = name this.color = color&#125;var cat1 = new Cat('name1', 'color1')alert(cat1.species) // 动物 prototype（其二） 12345678function Animal () &#123;&#125;Animal.prototype.species = '动物'Cat.prototype = Animal.prototypeCat.prototype.constructor = Catvar cat3 = new Cat('name3', 'color3')alert(cat3.species) // 动物 利用空对象作为中介 上面那种方法的缺点：Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。 1234var Fn = function () &#123;&#125;Fn.prototype = Animal.prototypeCat.prototype = new Fn()Cat.prototype.construvtor = Cat 将其封装成一个函数 12345678910function extend (Child, Parent) &#123; var Fn = function () &#123;&#125; Fn.prototype = Parent.prototype Child.prototype = new Fn() Child.prototype.constructor = Child&#125;extend(Cat, Animal)var cat4 = new Cat('name4', 'color4')alert(cat4.species) // 动物 拷贝继承 123456789101112131415function Animal () &#123;&#125;Animal.species = '动物'function extend2 () &#123; var C = Child.prototype var P = Parent.prototype for (var i in P) &#123; C[i] = P[i] &#125;&#125;extend2(Cat, Animal)var cat5 = new Cat('name5', 'color5')alert(cat5.species) // 动物 17. 非构造函数的继承123456var Chinese = &#123; nation: '中国'&#125;var Doctor = &#123; career: '医生'&#125; 浅拷贝 123456789101112function shallowCopy (Parent) &#123; var Child = &#123;&#125; for (var i in Parent) &#123; Child[i] = Parent[i] &#125; return Child&#125;var doctor1 = shallowCopy(Chinese)alert(doctor1.nation) // 中国 深拷贝 1234567891011121314151617function deepCopy (Child, Parent) &#123; var Child = Child || &#123;&#125; for (var i in Parent) &#123; if (typeof Parent[i] == 'object') &#123; Child[i] = (Parent[i].constructor === Array) ? [] : &#123;&#125; deepCopy(Child[i], Parent[i]) &#125; else &#123; Child[i] = Parent[i] &#125; &#125; return Child&#125;var doctor2 = deepCopy(Doctor, Chinese)alert(doctor.nation) // 中国 18. 参考链接","comments":true,"tags":[{"name":"dairy","slug":"dairy","permalink":"https://JnathanCoder.github.io/tags/dairy/"}]},{"title":"forEach遍历中断","date":"2019-05-22T09:28:36.000Z","path":"2019/05/22/forEach-interrupt/","text":"123456789101112131415try &#123; [22, 34, 20, 36, 98].forEach( (value, index, arr) =&gt; &#123; if (value === 20) &#123; console.log('遇到20能够退出循环吗？') throw Error('自定义异常提示语') return // return并不能中断循环，这里可写可不写 &#125; else console.log('当前遍历值：', value) &#125;)&#125; catch(err) &#123; console.log(err.message)&#125;// 22// 34// 遇到20能够退出循环吗？// 自定义异常提示语","comments":true,"tags":[]},{"title":"使用 void 0 代替 undefined","date":"2019-05-22T09:02:31.000Z","path":"2019/05/22/void-0/","text":"What…1void 0 === undefined // true Why？ 防止undefined被重写 在ES5之前，window下的undefined是可以被重写的，于是导致了某些极端情况下使用undefined会出现一定的差错。 所以，用void 0是为了防止undefined被重写而出现判断不准确的情况。 事实上，void的返回值都是undefined。ES5之后的标准中，规定了全局变量下的undefined值为只读，不可改写的，但是局部变量中依然可以对之进行改写。补充一下：非严格模式下，undefined是可以重写的，严格模式则不能重写。 节省字节 void 0代替undefined节省3个字节，类似的还有以下用法： 1234567891011121314151617181920212223242526272829303132// 取整操作parseInt(a,10) // BeforeMath.floor(a) // Beforea&gt;&gt;0 // Before~~a // Aftera|0 // After// 四舍五入操作Math.round(a) // Beforea+.5|0 // After// 内置值undefined // Beforevoid 0 // After, 快0[0] // After, 略慢// 内置值Infinity1/0// 布尔值短写法true; // Beforefalse // Before!1 // After!0; // After// 获取上下文对象var global = (function () &#123; return this || (0, eval)('this')&#125;())// (0, eval)('this') 等价于 eval('this') 正常情况下可以直接使用 eval()// 部分低版本IE下，不可以直接运行eval()。","comments":true,"tags":[]},{"title":"this + bind + call + apply","date":"2019-05-21T07:05:59.000Z","path":"2019/05/21/this/","text":"this的指向 this的指向总结起来就是this永远指向最后调用它的那个对象 例1： 123456789var name = 'global'function test() &#123; var name = 'cherry' console.log(this) console.log(this.name)&#125;test()// window// global 调用 test 方法的地方是 test() ，前面没有调用的对象即为 window （严格模式下为 undefined ），相当于 window.test() 。 例2： 123456789var name = 'global'var obj = &#123; name: 'cherry', fn: function () &#123; console.log(this.name) &#125;&#125;obj.fn() // cherrywindow.obj.fn() // cherry obj.fn() 取用的是 obj 对象 里面的 name 值， window.obj.fn() 里面，最后调用的是 obj 对象，所以也是 cherry 。补充：假如将 obj 对象中 name 属性的定义注释掉，那么 obj.fn() 将会打印出 undefined ，因为只会看最近的调用 obj 对象 ，当没有定义时，不会继续向上一个对象 window 寻找 name 属性。 例3： 123456789var name = 'global'var obj = &#123; name: 'cherry', fn: function () &#123; console.log(this.name) &#125;&#125;var temp = obj.fn()temp() // global 再来看一遍：this 永远指向 最后调用 它的那个对象。 obj.fn() 赋值给 temp 时，并没有进行赋值！最后 temp() 调用的时候是 window.temp() ，所以打印 global 。 例4： 123456789var name = 'global'function fn () &#123; var name = 'cherry' innerFn() function innerFn () &#123; console.log(this.name) &#125;&#125;fn() // global 例5： 1234567891011121314151617181920function Func () &#123; this.name = 'cherry'&#125;var fn = new Func()console.log(fn.name) // cherry// =================================function Func2 () &#123; this.name = 'cherry' return &#123;name: 'apple'&#125; // 返回一个对象 如果name改为name2，fn2.name为undefined&#125;function Func3 () &#123; this.name = 'cherry' return true // 返回true，非对象（false, 124, 'abc'都可）&#125;var fn2 = new Func2()console.log(fn2.name) // applevar fn3 = new Func3()console.log(fn3.name) // cherry 当我们通过 new 关键字构造一个实例对象的过程中，构造函数中的 this 一般情况下指向我们构造出来的实例化对象，因此在构造过程中 this.name = &#39;cherry&#39; 这句代码就相当于给实例对象 fn 创建了一个 name 属性并赋值 cherry 。特别的，当构造函数中的 this 遇到 return 的情况。当构造函数中返回值是一个对象时，this 指向的就是返回的那个对象；如果返回值不是对象时，this 指向的就是构造函数（这里是 Func3 ）。 改变this的指向例6： 12345678910111213var name = 'global'var obj = &#123; name: 'cherry', fn1: function () &#123; console.log(this.name) &#125;, fn2: function () &#123; setTimeout(function () &#123; this.fn1() &#125;, 1000) &#125;&#125;obj.fn2() // this.fn1 is not a function setTimeout() 即为 window.setTimeout() ，最后调用的对象是 window，而 window 中并没有方法 fn1() ，故而报错。 我们通常使用以下几种方法改变this的指向问题： var _this = this 12345678// ...fn2: function () &#123; var _this = this setTimeout(function () &#123; _this.fn1() // cherry &#125;, 1000)&#125;// ... 箭头函数 1234567// ...fn2: function () &#123; setTimeout( () =&gt; &#123; this.fn1() // cherry &#125;, 1000)&#125;// ... bind 1234567// ...fn2: function () &#123; setTimeout(function () &#123; this.fn1() // cherry &#125;. bind(obj)(), 1000) // 这里的obj也可以换成this this指向obj&#125;// ... call 1234567// ...fn2: function () &#123; setTimeout(function () &#123; this.fn1() // cherry &#125;.call(obj), 1000) // 这里的obj也可以换成this this指向obj&#125;// ... apply 1234567// ...fn2: function () &#123; setTimeout(function () &#123; this.fn1() // cherry &#125;.apply(obj), 1000) // 这里的obj也可以换成this this指向obj&#125;// ... bind介绍 bind() 方法创建一个 新的函数， 当被调用时，将其 this 关键字设置为提供的值。在调用新函数时，在任何提供之前提供一个给定的参数序列。 例7： 123456789var obj = &#123; func: function (a, b) &#123; console.log('乘积： ' + a * b) &#125;&#125;obj.func.bind(obj, 2, 8) // f (a, b) &#123; // console.log('乘积： ' + a * b) // &#125;obj.func.bind(obj, 2, 8)() // 乘积： 16 因为 bind 只会重新赋予 this，并不会自动执行，需要手动执行，固有第二个的结果。 call介绍 functionObj.call(thisArg[, args1, args2, args3, …]) thisArg -&gt; 函数在运行时指定的 this 。当为 null 或者 undefined 时，自动指向 window 。当为string 、number 、boolean 类型的时候，this 指向各自的包装对象。 123456789101112function test () &#123; console.log('this: ' + this)&#125;test.call(null) // windowtest.call(undefined) // windowtest.call('abcd') // Stringtest.call(128) // Numbertest.call(false) // Boolean// apply() 的结果与 call() 一致test.apply(null) // window// ... 例8： 1234567var obj = &#123; name: 'hello', func: function (a, b) &#123; console.log('乘积： ' + a * b) &#125;&#125;obj.func.call(obj, 2, 5) // 乘积： 10 apply介绍 functionObj.apply(thisArg[, argsArr]) apply 的语法和 call 的语法类似，区别在于 apply 的参数列表是以 数组 或者 类数组 形式传入。 例9： 1234567var obj = &#123; name: 'hello', func: function (a, b) &#123; console.log('乘积： ' + a * b) &#125;&#125;obj.func.apply(obj, [2, 6]) // 乘积： 12 call、apply常见用法 将类数组 ArrayLike 转换成数组 Array 12345678910111213141516var arraylike = &#123;'1': 'hello', '2': 'world', '3': 'balabala', length: 4&#125;function ArrTransfer () &#123; // return [].slice.call(arguments) return Array.prototype.slice.call(arguments) // return [].splice.call(arguments, 0) // return Array.prototype.splice.call(arguments, 0) // return Array.from(arguments)&#125;var list = ArrTransfer(arrayLike) // [&#123;'1': 'hello', '2': 'world', '3': 'balabala', length: 3&#125;]Array.prototype.slice.call(arrayLike).forEach( (elem, index) =&gt; &#123; console.log(elem, index) // hello 1 // world 2 // balabala 3&#125;) 求最大最小值 123var arr = [21, 2, 35, 9, 23, 16, 29]Math.max.apply(Math, arr) // 35Math.min.apply(Math, arr) // 2 Useful Link 全文参考自掘金文章","comments":true,"tags":[{"name":"this","slug":"this","permalink":"https://JnathanCoder.github.io/tags/this/"},{"name":"作用域","slug":"作用域","permalink":"https://JnathanCoder.github.io/tags/作用域/"}]},{"title":"企业微信中超链接地址跳转","date":"2019-05-21T03:04:11.000Z","path":"2019/05/21/wxwork-link-unRirect/","text":"问题描述：在ios(版本号未测试)企业微信(版本号未测试)中，并且超链接target属性是_blank时，点击超链接不能正常跳转，当前页面自动刷新一次。而在ios微信浏览器以及android中未复现。 解决办法 直接修改target属性值为非_blank即可； 如果是从富文本编辑器中出来的html内容，可以借助js进行处理。示意代码如下： 1234let oAList = document.querySelectorAll('a')Array.from(oAList).forEach( (aLink, index) =&gt; &#123; aLink.getAttribute('target') === '_blank' ? aLink.setAttribute('target', '_self') : null // 设置成null也可&#125;)","comments":true,"tags":[{"name":"企微","slug":"企微","permalink":"https://JnathanCoder.github.io/tags/企微/"},{"name":"超链接","slug":"超链接","permalink":"https://JnathanCoder.github.io/tags/超链接/"}]},{"title":"CSS文本超出容器宽度使用省略号代替（不考虑js方法）","date":"2019-03-31T16:00:00.000Z","path":"2019/04/01/text-overflow-ellipsis/","text":"方法一 ：常规方法（适用于webkit内核浏览器）12&lt;div class=\"container text-ellipsis\"&gt;单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号&lt;/div&gt;&lt;div class=\"container text-ellipsis-multi\"&gt;多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号&lt;/div&gt; 1234567891011121314151617181920.container &#123; display: inline-block; width: 333px; height: 60px; font-size: 16px; border: 1px solid #00bebe;&#125;.text-ellipsis &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;.text-ellipsis-multi &#123; line-height: 20px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; // 控制显示的行数 -webkit-box-orient: vertical&#125; 在webkit浏览器中的表现： 方法二：利用伪类+float（适用于大部分浏览器）123&lt;div class=\"wrap\"&gt; &lt;div class=\"text\"&gt;多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132.wrap &#123; width: 333px; height: 60px; line-height: 20px; overflow: hidden; border: 1px solid #00bebe;&#125;.wrap:before &#123; float: left; content: ''; width: 5px; height: 100%;&#125;.wrap:after &#123; float: right; content: '...'; width: 20px; margin-left: -20px; height: 20px; line-height: 20px; margin-right: 5px; background: #fff; position: relative; top: -20px; left: 100%;&#125;.wrap .text &#123; float: right; width: 100%; margin-left: -5px; word-break: break-all;&#125; 在非webkit内核浏览器中的表现： 可以看到效果还是不那么尽人意，可以在此基础上再根据实际情况修改相应代码，比如...用渐变色代替现在的白色，会显得平滑。另外，也可以搭配js进一步处理，可以参考这里。","comments":true,"tags":[{"name":"ellipsis","slug":"ellipsis","permalink":"https://JnathanCoder.github.io/tags/ellipsis/"},{"name":"换行","slug":"换行","permalink":"https://JnathanCoder.github.io/tags/换行/"},{"name":"省略号","slug":"省略号","permalink":"https://JnathanCoder.github.io/tags/省略号/"}]}]