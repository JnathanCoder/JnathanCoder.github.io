[{"title":"日志，内容会持续补充...","date":"2019-05-22T09:43:43.000Z","path":"2019/05/22/multiple-diary/","text":"1. setTimeout中方法体添加引号与不添加引号的区别 添加引号的情况，调用的函数是全局范围的。未添加引号的情况，调用的是局部范围的。 1234567891011121314151617var testFn = function () &#123; console.info('hello from global')&#125;var fn = function () &#123; var testFn = function () &#123; console.info('hello fron inner') &#125; setTimeout('testFn()', 1000) // hello form global setTimeout(testFn, 1000) // hello from inner // 在fn()函数内部没有定义testFn的时候，会向上寻找testFn，这里找到了全局函数，执行效果： setTimeout(testFn, 1000) // hello from global&#125;fn() 2. AMD/CMD规范 common.jscommon.js 运行在服务器端，因为模块就在磁盘上，所以加载时间几乎可以忽略不计，属于同步加载。 [典型代表 node.js]AMD与CMD都属于异步加载，运行在浏览器端。AMD 推崇依赖前置，定义模块的时候就需要申明需要依赖的模块 [典型代表 require.js]CMD 推崇依赖就近，需要用到的时候才去require相关模块 [典型代表 sea.js] 3. stopPropagation() 以及 stopImmediatePropagation()stopImmediatePropagation 用于阻止冒泡，在执行完当前元素上的事件处理程序之后，停止当前元素以及后续元素的事件处理程序 stopPropagation 同样也是用于阻止冒泡，在执行完绑定到当前元素上的所有事件处理程序之后，停止后续元素的事件处理程序 同一个元素用on绑定多次同样事件时（例如click），最后一次会覆盖之前的事件，不会执行前面。而用addEventListener绑定多次同样事件时，都会执行。 12345&lt;div id=\"large\" style=\"width: 150px; height: 150px; background: orange\"&gt; &lt;div id=\"middle\" style=\"width: 100px; height: 100px; background: cadetblue\"&gt; &lt;div id=\"small\" style=\"width: 50px; height:50px; background: coral\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546(function()&#123; var large = document.getElementById('large') var middle = document.getElementById('middle') var small = document.getElementById('small') large.addEventListener('click', function()&#123; alert('large div is clicked') &#125;) middle.addEventListener('click', function()&#123; alert('middle div is clicked') &#125;) // 第一种情况： 点击small时，会依次弹出三个窗口，这是因为向上冒泡产生的 small.addEventListener('click', function()&#123; alert('small div is clicked') &#125;) // 第二种情况： 点击small时，会弹出四个窗口 // small.addEventListener('click', function()&#123; // alert('small-1 is clicked') // &#125;) // small.addEventListener('click', function()&#123; // alert('small-2 is clicked') // &#125;) // 第三种情况，添加stopPropagation： 点击small时，会弹出两个窗口 // small-1 is clicked small-2 is clicked // small.addEventListener('click', function(event)&#123; // alert('small-1 is clicked') // event.stopPropagation() // &#125;) // small.addEventListener('click', function()&#123; // alert('small-2 is clicked') // &#125;) // 第四种情况，添加stopImmediatePropagation： 点击small时，会弹出一个窗口 // small-1 is clicked // 能够很明显看到与stopPropagation的区别，调用stopImmediatePropagation之后，第二个定义的click事件也被取消而不被执行了。 // small.addEventListener('click', function(event)&#123; // alert('small-1 is clicked') // event.stopImmediatePropagation() // &#125;) // small.addEventListener('click', function()&#123; // alert('small-2 is clicked') // &#125;)&#125;)() (function(){ var large = document.getElementById('large') var middle = document.getElementById('middle') var small = document.getElementById('small') large.addEventListener('click', function(){ alert('large div is clicked') }) middle.addEventListener('click', function(){ alert('middle div is clicked') }) // 第一种情况： 点击small时，会依次弹出三个窗口，这是因为向上冒泡产生的 small.addEventListener('click', function(){ alert('small div is clicked') }) // 第二种情况： 点击small时，会弹出四个窗口 // small.addEventListener('click', function(){ // alert('small-1 is clicked') // }) // small.addEventListener('click', function(){ // alert('small-2 is clicked') // }) // 第三种情况，添加stopPropagation： 点击small时，会弹出两个窗口 // small-1 is clicked small-2 is clicked // small.addEventListener('click', function(event){ // alert('small-1 is clicked') // event.stopPropagation() // }) // small.addEventListener('click', function(){ // alert('small-2 is clicked') // }) // 第四种情况，添加stopImmediatePropagation： 点击small时，会弹出一个窗口 // small-1 is clicked // 能够很明显看到与stopPropagation的区别，调用stopImmediatePropagation之后，第二个定义的click事件也被取消而不被执行了。 // small.addEventListener('click', function(event){ // alert('small-1 is clicked') // event.stopImmediatePropagation() // }) // small.addEventListener('click', function(){ // alert('small-2 is clicked') // }) })() 4. js事件中的三个阶段三个阶段分别为捕获阶段 目标阶段 冒泡阶段element.addEventListener(type, fn[, useCapture])useCapture - 指定事件句柄在捕获阶段或者冒泡阶段执行， 默认false(事件句柄在冒泡阶段执行)，设置为true(事件句柄在捕获阶段执行)。 捕获阶段 目标阶段 冒泡阶段 5. 常见的前端性能优化手段 css sprites（雪碧图） 避免使用css表达式 css样式表放在页面顶部，脚本放在页面底部 内联图片和脚本使用data:URL（base64编码）模式直接包含在页面中，无需进行http请求，缺点：ie不支持，图片太大不适用，使用base64会增加页面体积，浏览器不会缓存 使用内容分发网络CDN 开启GZIP压缩，启用负载均衡 开启keep alive减少与服务器链接次数 缺点：使服务器负载增大，也更容易遭受攻击 精简压缩代码 uglifyjs 避免重定向 常见的301 302 配置e-tags 和 expires头 使用缓存 按需加载资源 6. parseInt() 以及 parseFloat() parseInt(string[, radix]) string如果以‘ox’或者’oX’开头，将以16进制进行解析 radix 要解析的数字基数，介于2-36之间 如果不给值或者为0，则按照基数为10来计算 如果小于2或者大于36，则返回NaN 开头和结尾的空格是允许的 如果字符串的第一个字符不能转换成对应的数字，将返回NaN 12345678910111213141516171819parseInt('0x12') // 17parseInt('0x12', 2) // 0 =&gt; parseInt('0', 2)parseInt('0x12', 10) // 0 =&gt; parseInt('0', 16)parseInt('8') // =&gt; parseInt('8', 0) =&gt; parseInt('8', 10) // 8parseInt('8', 1) // NaNparseInt('8', 37) // NaNparseInt('a23') // NaNparseInt('2a3') // 2parseInt(' 23') // 23parseInt(' 23 ') // 23parseInt(' 2 3 ') // 2parseInt('11', 2) // 3parseInt(11, 2) // 3parseInt('1100', 2) // 12parseInt('21', 2) // NaN 2超出了2进制最大值1，并且是第一个字符parseInt('12', 2) // 1 2同样超出了2进制最大值1，但是第一个字符可以转换成二进制parseInt('66', 8) // 6*8^1 + 6*8^0 = 48 + 6 = 54parseInt('12', 16) // 1*16^1 + 2*16^0 = 16 + 2 = 18[0, 1, 2, 3].map(parseInt) // [parseInt(0, 0), parseInt(1, 1), parseInt(2, 2), parseInt(3, 3)] =&gt; [0, NaN, NaN, NaN] parseFloat() parseInt(string[, radix]) 这里语法待修改 开头和结尾的空格是允许的 如果字符串的第一个字符不能转换成对应的数字，将返回NaN 如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符 7. 原生ajax12345678910var xhr = new XMLHttpRequest()// 请求方式 请求路径 是否异步发送请求xhr.open('GET', 'http://www.jnathan.cn/jnathan/effect/authKit.js', true)xhr.send('hello world') xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // alert(xhr.responseText) &#125;&#125; 8. 有一个长度为n的数组，假定全部为整数，其中有且仅有一个数出现了奇数次，其他的数字都出现偶数次，找出出现了奇数次的那个数字。 时间复杂度为O(n) 空间复杂度O(1)利用了n ^ n = 0, n ^ 0 = n两个等式的原理。循环对数组数字进行异或计算，即 0 ^ arr[0] ^ arr[1] ^ ... ^ arr[n - 1] ，异或计算满足交换律原则，如果数组元素出现了相同的情况，可以移动到一起先进行计算，如果出现了偶数次，其结果为 0，出现了奇数次的数其结果为该数字，所以表达式最后得出来的结果即为数组所有出现了奇数次元素的异或操作的结果。比如：[1,2,2,3,4,4]进行异或操作得到的结果是 1 ^ 3 = 2 ，特殊情况下（只有一个数字出现了奇数次），那么最后的结果就是出现了奇数次的那个数字！！ 123456789function fn7 (arr) &#123; var oddTimesNumber = 0 for (let i in arr) &#123; oddTimesNumber = oddTimesNumber ^ arr[i] &#125; return oddTimesNumber&#125;fn7([1,2,3,4,5,4,4,3,2,1,1,1]) // 3 9. 递归求1-10的和123456789101112function getSum(nextArr, curSum = 0) &#123; var sum = nextArr[0] + curSum if (nextArr.length == 1) &#123; return sum &#125; else &#123; return getSum(nextArr.slice(1), sum) &#125;&#125;getSum([1,2,3,4,5,6,7,8,9,10]) 10. 去除数组重复元素 直接双层循环比较 123456789101112131415161718192021222324function unique (arr) &#123; var result = [] var isRepeat for (var i = 0; i &lt; arr.length; i++) &#123; isRepeat = false // 默认不重复，进行push操作，当判断重复时不操作 for (var j = 0; j &lt; result.length; j++) &#123; if (arr[i] === result[j]) &#123; isRepeat = true break &#125; &#125; if (!isRepeat) &#123; result.push(arr[i]) &#125; &#125; return result&#125;unique([1,1,2,3,4]) 利用indexOf()， 但是indexOf会一直循环到找到目标为止，浪费了时间 12345678910111213function unique (arr) &#123; var result = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (result.indexOf(arr[i]) === -1) &#123; result.push(arr[i]) &#125; &#125; return result&#125;unique([1,1,2,3,4]) 最快的方法 把已经出现过的元素通过下标的形式存入一个Object内。下标的引用的实现原理利用的是哈希算法，要比用indexOf()搜索数组快的多。由于多了一个hash表，占用的内存会更多，空间换时间做法 1234567891011121314function unique (arr) &#123; // hashObj为hash表，result为临时数组 var hashObj = &#123;&#125;, result = [] for (var i = 0; i &lt; arr.length; i++) &#123; // 如果hash表中没有当前项 if (!hashObj[arr[i]]) &#123; // 存入hash表 hashObj[arr[i]] = true // 把当前数组的当前项push到临时数组里面 result.push(arr[i]) &#125; &#125; return result&#125; 折衷方法 时间上比indexOf快，比hash表的方式要慢。先按照从小到大的顺序排序，然后比较相邻的两个值大小 12345678910function unique (arr) &#123; arr.sort() var result = [arr[0]] for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== result[result.length - 1]) &#123; result.push(arr[i]) &#125; &#125; return result&#125; es6的filter()方法 1234567891011121314function unique (arr) &#123; return arr.filter( (value, index) =&gt; &#123; arr.indexOf(value) === index console.log(arr.indexOf(value), index) // 0 0 // 0 1 // 2 2 // 3 3 // 4 4 // 5 5 // 2 6 &#125;)&#125;unique([1,1,2,3,4,5,2]) 11. jquery 里面的 $(document).ready(function(){}) 和 window.onload 的区别 window.onload需要等到页面中包括图片在内的元素全部加载完毕才能执行；ready()是DOM元素绘制结束之后就执行，不用等到加载完毕。 window.onload如果定义了多次，则只会执行一个，后者会覆盖前者； ready()可以同时编写多个，并且都会执行。 window.onload没有简化写法；$(document).ready(function(){})可以简化成$(function(){})。 补充：$(window).load(function(){})和 window.onload()效果一致。 12. 渐进增强与优雅降级 渐进增强 一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再对高级浏览器进行效果、交互的优化，达到更好的体验。 优雅降级 一开始就构建站点的完整功能，然后针对浏览器进行测试和修复。比如一开始使用CSS3的特性构建了一个应用，然后逐步针对各大低级浏览器进行hack使其可以在低版本浏览器上正常浏览。 13. cookies、localStorage和sessionStorage的区别 cookies存在于客户端，始终会在http请求中通过 Request Headers Cookie头携带，即使当前请求不需要使用到cookie；大小一般在4KB，所以只适合保存很小的数据，比如会话标识；cookies在没有设置过期时间（expires）的时候，默认在关闭浏览器之后就会被清除，在有设置过期时间的时候，会一直持续到过期时间有效（即使关闭当前窗口或者关闭浏览器）。 localStorage 和 sessionStorage不会发送数据到服务端，仅在本地保存；也有大小的限制，但一般在5M左右；localStorage一直有效，除非手动清除； sessionStorage只在浏览器关闭之前有效。 另外： localStorage 和 cookies 在同源的浏览器窗口之间是共享的，sessionStorage不共享，因此至少有以下两种方法实现不同页面间的通信： 利用localStorage 123456789// A页面$('#btn').click(function()&#123; localStorage.setItem('name', 'Jnathan')&#125;)// B页面window.addEventListener('storage', function(event)&#123; console.log(event.key + '=' + event.newValue)&#125;) 利用cookie + setInterval() 123456789101112// A页面$('#btn').click(function () &#123; document.cookie = \"name=\" + 'Jnathan'&#125;)// B页面function getKey(key) &#123; return JSON.parse(\"&#123;\\\"\"+ document.cookie.replace(/;\\s+/gim,\"\\\",\\\"\").replace(/=/gim, \"\\\":\\\"\") +\"\\\"&#125;\")[key]; &#125;setInterval(function()&#123; console.log('name:', getKey('name'))&#125;, 1000) 14. new 操作符的四个步骤12var Fn = function() &#123;&#125;var fn = new Fn() 创建一个空对象 1var obj = new Object() 设置obj的原型，将obj的原型指向Fn的原型链 1obj.__proto__ = Fn.prototype 将Fn中的this指向obj,并执行Fn 1var result = Fn.call(obj) 判断Fn的返回值类型。如果是引用类型，则返回这个引用类型的对象；如果是值类型，则返回obj` 12345if (typeof result == 'object') &#123; // 引用类型 fn = result&#125; else &#123; // 值类型 fn = obj&#125; 15. 构造函数实现继承的几种方式1234567function Animal () &#123; this.species = '动物'&#125;function Cat (name, color) &#123; this.name = name this.color = color&#125; 使猫继承动物： call apply 12345678function Cat (name, color) &#123; Animal.apply(this, arguments) this.name = name this.color = color&#125;var cat1 = new Cat('name1', 'color1')alert(cat1.species) // 动物 prototype（其一） 12345678function Cat (name, color) &#123; Animal.apply(this, arguments) this.name = name this.color = color&#125;var cat1 = new Cat('name1', 'color1')alert(cat1.species) // 动物 prototype（其二） 12345678function Animal () &#123;&#125;Animal.prototype.species = '动物'Cat.prototype = Animal.prototypeCat.prototype.constructor = Catvar cat3 = new Cat('name3', 'color3')alert(cat3.species) // 动物 利用空对象作为中介 上面那种方法的缺点：Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。 1234var Fn = function () &#123;&#125;Fn.prototype = Animal.prototypeCat.prototype = new Fn()Cat.prototype.construvtor = Cat 将其封装成一个函数 12345678910function extend (Child, Parent) &#123; var Fn = function () &#123;&#125; Fn.prototype = Parent.prototype Child.prototype = new Fn() Child.prototype.constructor = Child&#125;extend(Cat, Animal)var cat4 = new Cat('name4', 'color4')alert(cat4.species) // 动物 拷贝继承 123456789101112131415function Animal () &#123;&#125;Animal.species = '动物'function extend2 () &#123; var C = Child.prototype var P = Parent.prototype for (var i in P) &#123; C[i] = P[i] &#125;&#125;extend2(Cat, Animal)var cat5 = new Cat('name5', 'color5')alert(cat5.species) // 动物 16. 非构造函数的继承123456var Chinese = &#123; nation: '中国'&#125;var Doctor = &#123; career: '医生'&#125; 浅拷贝 123456789101112function shallowCopy (Parent) &#123; var Child = &#123;&#125; for (var i in Parent) &#123; Child[i] = Parent[i] &#125; return Child&#125;var doctor1 = shallowCopy(Chinese)alert(doctor1.nation) // 中国 深拷贝 1234567891011121314151617function deepCopy (Child, Parent) &#123; var Child = Child || &#123;&#125; for (var i in Parent) &#123; if (typeof Parent[i] == 'object') &#123; Child[i] = (Parent[i].constructor === Array) ? [] : &#123;&#125; deepCopy(Child[i], Parent[i]) &#125; else &#123; Child[i] = Parent[i] &#125; &#125; return Child&#125;var doctor2 = deepCopy(Doctor, Chinese)alert(doctor.nation) // 中国 17. 参考链接","comments":true,"tags":[{"name":"dairy","slug":"dairy","permalink":"https://JnathanCoder.github.io/tags/dairy/"}]},{"title":"forEach遍历中断","date":"2019-05-22T09:28:36.000Z","path":"2019/05/22/forEach-interrupt/","text":"123456789101112131415try &#123; [22, 34, 20, 36, 98].forEach( (value, index, arr) =&gt; &#123; if (value === 20) &#123; console.log('遇到20能够退出循环吗？') throw Error('自定义异常提示语') return // return并不能中断循环，这里可写可不写 &#125; else console.log('当前遍历值：', value) &#125;)&#125; catch(err) &#123; console.log(err.message)&#125;// 22// 34// 遇到20能够退出循环吗？// 自定义异常提示语","comments":true,"tags":[]},{"title":"使用 void 0 代替 undefined","date":"2019-05-22T09:02:31.000Z","path":"2019/05/22/void-0/","text":"What…1void 0 === undefined // true Why？ 防止undefined被重写 在ES5之前，window下的undefined是可以被重写的，于是导致了某些极端情况下使用undefined会出现一定的差错。 所以，用void 0是为了防止undefined被重写而出现判断不准确的情况。 事实上，void的返回值都是undefined。ES5之后的标准中，规定了全局变量下的undefined值为只读，不可改写的，但是局部变量中依然可以对之进行改写。补充一下：非严格模式下，undefined是可以重写的，严格模式则不能重写。 节省字节 void 0代替undefined节省3个字节，类似的还有以下用法： 1234567891011121314151617181920212223242526272829303132// 取整操作parseInt(a,10) // BeforeMath.floor(a) // Beforea&gt;&gt;0 // Before~~a // Aftera|0 // After// 四舍五入操作Math.round(a) // Beforea+.5|0 // After// 内置值undefined // Beforevoid 0 // After, 快0[0] // After, 略慢// 内置值Infinity1/0// 布尔值短写法true; // Beforefalse // Before!1 // After!0; // After// 获取上下文对象var global = (function () &#123; return this || (0, eval)('this')&#125;())// (0, eval)('this') 等价于 eval('this') 正常情况下可以直接使用 eval()// 部分低版本IE下，不可以直接运行eval()。","comments":true,"tags":[]},{"title":"this + bind + call + apply","date":"2019-05-21T07:05:59.000Z","path":"2019/05/21/this/","text":"this的指向 this的指向总结起来就是this永远指向最后调用它的那个对象 例1： 123456789var name = 'global'function test() &#123; var name = 'cherry' console.log(this) console.log(this.name)&#125;test()// window// global 调用 test 方法的地方是 test() ，前面没有调用的对象即为 window （严格模式下为 undefined ），相当于 window.test() 。 例2： 123456789var name = 'global'var obj = &#123; name: 'cherry', fn: function () &#123; console.log(this.name) &#125;&#125;obj.fn() // cherrywindow.obj.fn() // cherry obj.fn() 取用的是 obj 对象 里面的 name 值， window.obj.fn() 里面，最后调用的是 obj 对象，所以也是 cherry 。补充：假如将 obj 对象中 name 属性的定义注释掉，那么 obj.fn() 将会打印出 undefined ，因为只会看最近的调用 obj 对象 ，当没有定义时，不会继续向上一个对象 window 寻找 name 属性。 例3： 123456789var name = 'global'var obj = &#123; name: 'cherry', fn: function () &#123; console.log(this.name) &#125;&#125;var temp = obj.fn()temp() // global 再来看一遍：this 永远指向 最后调用 它的那个对象。 obj.fn() 赋值给 temp 时，并没有进行赋值！最后 temp() 调用的时候是 window.temp() ，所以打印 global 。 例4： 123456789var name = 'global'function fn () &#123; var name = 'cherry' innerFn() function innerFn () &#123; console.log(this.name) &#125;&#125;fn() // global 例5： 1234567891011121314151617181920function Func () &#123; this.name = 'cherry'&#125;var fn = new Func()console.log(fn.name) // cherry// =================================function Func2 () &#123; this.name = 'cherry' return &#123;name: 'apple'&#125; // 返回一个对象 如果name改为name2，fn2.name为undefined&#125;function Func3 () &#123; this.name = 'cherry' return true // 返回true，非对象（false, 124, 'abc'都可）&#125;var fn2 = new Func2()console.log(fn2.name) // applevar fn3 = new Func3()console.log(fn3.name) // cherry 当我们通过 new 关键字构造一个实例对象的过程中，构造函数中的 this 一般情况下指向我们构造出来的实例化对象，因此在构造过程中 this.name = &#39;cherry&#39; 这句代码就相当于给实例对象 fn 创建了一个 name 属性并赋值 cherry 。特别的，当构造函数中的 this 遇到 return 的情况。当构造函数中返回值是一个对象时，this 指向的就是返回的那个对象；如果返回值不是对象时，this 指向的就是构造函数（这里是 Func3 ）。 改变this的指向例6： 12345678910111213var name = 'global'var obj = &#123; name: 'cherry', fn1: function () &#123; console.log(this.name) &#125;, fn2: function () &#123; setTimeout(function () &#123; this.fn1() &#125;, 1000) &#125;&#125;obj.fn2() // this.fn1 is not a function setTimeout() 即为 window.setTimeout() ，最后调用的对象是 window，而 window 中并没有方法 fn1() ，故而报错。 我们通常使用以下几种方法改变this的指向问题： var _this = this 12345678// ...fn2: function () &#123; var _this = this setTimeout(function () &#123; _this.fn1() // cherry &#125;, 1000)&#125;// ... 箭头函数 1234567// ...fn2: function () &#123; setTimeout( () =&gt; &#123; this.fn1() // cherry &#125;, 1000)&#125;// ... bind 1234567// ...fn2: function () &#123; setTimeout(function () &#123; this.fn1() // cherry &#125;. bind(obj)(), 1000) // 这里的obj也可以换成this this指向obj&#125;// ... call 1234567// ...fn2: function () &#123; setTimeout(function () &#123; this.fn1() // cherry &#125;.call(obj), 1000) // 这里的obj也可以换成this this指向obj&#125;// ... apply 1234567// ...fn2: function () &#123; setTimeout(function () &#123; this.fn1() // cherry &#125;.apply(obj), 1000) // 这里的obj也可以换成this this指向obj&#125;// ... bind介绍 bind() 方法创建一个 新的函数， 当被调用时，将其 this 关键字设置为提供的值。在调用新函数时，在任何提供之前提供一个给定的参数序列。 例7： 123456789var obj = &#123; func: function (a, b) &#123; console.log('乘积： ' + a * b) &#125;&#125;obj.func.bind(obj, 2, 8) // f (a, b) &#123; // console.log('乘积： ' + a * b) // &#125;obj.func.bind(obj, 2, 8)() // 乘积： 16 因为 bind 只会重新赋予 this，并不会自动执行，需要手动执行，固有第二个的结果。 call介绍 functionObj.call(thisArg[, args1, args2, args3, …]) thisArg -&gt; 函数在运行时指定的 this 。当为 null 或者 undefined 时，自动指向 window 。当为string 、number 、boolean 类型的时候，this 指向各自的包装对象。 123456789101112function test () &#123; console.log('this: ' + this)&#125;test.call(null) // windowtest.call(undefined) // windowtest.call('abcd') // Stringtest.call(128) // Numbertest.call(false) // Boolean// apply() 的结果与 call() 一致test.apply(null) // window// ... 例8： 1234567var obj = &#123; name: 'hello', func: function (a, b) &#123; console.log('乘积： ' + a * b) &#125;&#125;obj.func.call(obj, 2, 5) // 乘积： 10 apply介绍 functionObj.apply(thisArg[, argsArr]) apply 的语法和 call 的语法类似，区别在于 apply 的参数列表是以 数组 或者 类数组 形式传入。 例9： 1234567var obj = &#123; name: 'hello', func: function (a, b) &#123; console.log('乘积： ' + a * b) &#125;&#125;obj.func.apply(obj, [2, 6]) // 乘积： 12 call、apply常见用法 将类数组 ArrayLike 转换成数组 Array 12345678910111213141516var arraylike = &#123;'1': 'hello', '2': 'world', '3': 'balabala', length: 4&#125;function ArrTransfer () &#123; // return [].slice.call(arguments) return Array.prototype.slice.call(arguments) // return [].splice.call(arguments, 0) // return Array.prototype.splice.call(arguments, 0) // return Array.from(arguments)&#125;var list = ArrTransfer(arrayLike) // [&#123;'1': 'hello', '2': 'world', '3': 'balabala', length: 3&#125;]Array.prototype.slice.call(arrayLike).forEach( (elem, index) =&gt; &#123; console.log(elem, index) // hello 1 // world 2 // balabala 3&#125;) 求最大最小值 123var arr = [21, 2, 35, 9, 23, 16, 29]Math.max.apply(Math, arr) // 35Math.min.apply(Math, arr) // 2 Useful Link 全文参考自掘金文章","comments":true,"tags":[{"name":"this","slug":"this","permalink":"https://JnathanCoder.github.io/tags/this/"},{"name":"作用域","slug":"作用域","permalink":"https://JnathanCoder.github.io/tags/作用域/"}]},{"title":"企业微信中超链接地址跳转","date":"2019-05-21T03:04:11.000Z","path":"2019/05/21/wxwork-link-unRirect/","text":"问题描述：在ios(版本号未测试)企业微信(版本号未测试)中，并且超链接target属性是_blank时，点击超链接不能正常跳转，当前页面自动刷新一次。而在ios微信浏览器以及android中未复现。 解决办法 直接修改target属性值为非_blank即可； 如果是从富文本编辑器中出来的html内容，可以借助js进行处理。示意代码如下： 1234let oAList = document.querySelectorAll('a')Array.from(oAList).forEach( (aLink, index) =&gt; &#123; aLink.getAttribute('target') === '_blank' ? aLink.setAttribute('target', '_self') : null // 设置成null也可&#125;)","comments":true,"tags":[{"name":"企微","slug":"企微","permalink":"https://JnathanCoder.github.io/tags/企微/"},{"name":"超链接","slug":"超链接","permalink":"https://JnathanCoder.github.io/tags/超链接/"}]},{"title":"CSS文本超出容器宽度使用省略号代替（不考虑js方法）","date":"2019-03-31T16:00:00.000Z","path":"2019/04/01/text-overflow-ellipsis/","text":"方法一 ：常规方法（适用于webkit内核浏览器）12&lt;div class=\"container text-ellipsis\"&gt;单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号&lt;/div&gt;&lt;div class=\"container text-ellipsis-multi\"&gt;多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号&lt;/div&gt; 1234567891011121314151617181920.container &#123; display: inline-block; width: 333px; height: 60px; font-size: 16px; border: 1px solid #00bebe;&#125;.text-ellipsis &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;.text-ellipsis-multi &#123; line-height: 20px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; // 控制显示的行数 -webkit-box-orient: vertical&#125; 在webkit浏览器中的表现： 方法二：利用伪类+float（适用于大部分浏览器）123&lt;div class=\"wrap\"&gt; &lt;div class=\"text\"&gt;多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132.wrap &#123; width: 333px; height: 60px; line-height: 20px; overflow: hidden; border: 1px solid #00bebe;&#125;.wrap:before &#123; float: left; content: ''; width: 5px; height: 100%;&#125;.wrap:after &#123; float: right; content: '...'; width: 20px; margin-left: -20px; height: 20px; line-height: 20px; margin-right: 5px; background: #fff; position: relative; top: -20px; left: 100%;&#125;.wrap .text &#123; float: right; width: 100%; margin-left: -5px; word-break: break-all;&#125; 在非webkit内核浏览器中的表现： 可以看到效果还是不那么尽人意，可以在此基础上再根据实际情况修改相应代码，比如...用渐变色代替现在的白色，会显得平滑。另外，也可以搭配js进一步处理，可以参考这里。","comments":true,"tags":[{"name":"ellipsis","slug":"ellipsis","permalink":"https://JnathanCoder.github.io/tags/ellipsis/"},{"name":"换行","slug":"换行","permalink":"https://JnathanCoder.github.io/tags/换行/"},{"name":"省略号","slug":"省略号","permalink":"https://JnathanCoder.github.io/tags/省略号/"}]}]