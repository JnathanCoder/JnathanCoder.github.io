[{"title":"Vue自定义指令 image-lazyLoad","date":"2020-08-13T09:37:41.000Z","path":"2020/08/13/image-lazyload/","text":"","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://JnathanCoder.github.io/tags/vue/"},{"name":"自定义指令， image","slug":"自定义指令，-image","permalink":"https://JnathanCoder.github.io/tags/自定义指令，-image/"},{"name":"lazyLoad","slug":"lazyLoad","permalink":"https://JnathanCoder.github.io/tags/lazyLoad/"}]},{"title":"Web Worker 简介","date":"2020-08-13T08:22:26.000Z","path":"2020/08/13/web-worker/","text":"背景 JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。 基本用法1const worker = new Worker(jsUrl[, &#123; name: 'yourWorkerName' &#125;]) Tips 分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。 Worker 线程所在的全局对象，与主线程不一样，不能使用 document、window、parent、alert()、confirm()，但是可以使用 console，并且使用 XMLHttpRequest 发起 AJAX 请求。 通过 importScript 加载进来的脚本文件里，同样不能使用 alert 等属性。加载多个脚本文件时，用逗号隔开。 Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。 主线程 API12345Worker.onerror(): 指定 error 事件的监听函数Worker.onmessage(): 指定 message 事件的监听函数Worker.onmessageerror(): 指定 messageerror 事件的监听函数Worker.postMessage(): 向 Worker 线程发送消息Worker.terminate(): 终止 Worker 线程 Worker线程 API123456self.name: Worker 的名字。该属性只读，由构造函数指定self.onmessage: 指定 message 事件的监听函数self.onmessageerror: 指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件self.close(): 关闭 Worker 线程self.postMessage(): 向产生这个 Worker 线程发送消息self.importScripts(): 加载 JS 脚本 示例worker.html12345678910111213141516171819202122232425&lt;input type=\"text\" class=\"text\"&gt;&lt;input type=\"button\" class=\"button\" value=\"发送\"&gt;const text = document.querySelector('.text')const button = document.querySelector('.button')const worker = new Worker('./worker.js', &#123; name: 'myworker' &#125;)worker.onmessage = function(event) &#123; console.log('主线程收到来自myworker线程传递的消息：', event.data) console.log('------------') worker.terminate() console.log('主线程终止myworker线程')&#125;// 当向myworker传递的消息无法序列化为字符串时 触发worker.onmessageerror = function(event) &#123; // ...&#125;worker.onerror = function() &#123; // ...&#125;button.addEventListener('click', () =&gt; &#123; console.log('主线程向myworker线程发送消息：', text.value) worker.postMessage(text.value)&#125;) worker.js1234567891011121314151617181920// 均输出 myworkerconsole.log(self.name, this.name, name)importScripts('./test-importScript.js')this.onmessage = function(event) &#123; console.log('myworker线程收到主线程传递的消息：', event.data) this.postMessage('myworker线程已收到主线程传递的消息') this.close() console.log('---------') console.log('myworker线程已主动断开与主线程的连接，不能再收到传递的消息')&#125;// 当向主线程传递的消息无法序列化为字符串时 触发this.onmessageerror = function() &#123; // ...&#125; test-importScript.js12// myworkerconsole.log(this.name) 参考Web Worker 使用教程 - 阮一峰","comments":true,"tags":[{"name":"worker","slug":"worker","permalink":"https://JnathanCoder.github.io/tags/worker/"},{"name":"web-worker","slug":"web-worker","permalink":"https://JnathanCoder.github.io/tags/web-worker/"}]},{"title":"== 和 ===","date":"2020-04-29T03:10:04.000Z","path":"2020/04/29/abstract-and-strict-equality/","text":"先来几个例子，带着问题一起思考：12345678910111213console.log([10] == 10); // trueconsole.log('10' == 10); // trueconsole.log([] == 0); // trueconsole.log(true == 1); // trueconsole.log([] == false); // trueconsole.log(![] == false); // trueconsole.log([] == ![]); // trueconsole.log('' == 0); // trueconsole.log('' == false); // trueconsole.log(null == false); // falseconsole.log(null == true); // falseconsole.log(!null == true); // trueconsole.log(null == undefined); // true 1. === (strict equality comparision)12345678910111213141516171819202122if (Type(x) !== Type(y)) return falseif (Type(x) === Type(y)) &#123; if (Type(x) === Undefined) return true if (Type(x) === Null) return true if (Type(x) === String) &#123; return 长度和对应位置上字符都相同 ? true : false &#125; if (Type(x) === Boolean) &#123; return xy同时为true或false ? true : false &#125; if (Type(x) === Symbol) &#123; return 同一个Symbol ? true : false &#125; if (Type(x) === Number) &#123; if (x === NaN) return false if (y === NaN) return false if (xy相等 例如 x = 8, y = 8) return true if (x = 0, y = -0) return true if (x = -0, y = 0) return true return false // 其他情况均返回false &#125;&#125; 2. == (abstract equality comparision)123456789101112if (Type(x) === Type(y)) return x === yif (Type(x) !== Type(y)) &#123; if (x === null &amp;&amp; y === undefined) return true if (x === undefined &amp;&amp; y === null) return true if (Type(x) === Number &amp;&amp; Type(y) === String) return x == ToNumber(y) if (Type(x) === String &amp;&amp; Type(y) === Number) return ToNumber(x) == y if (Type(x) === Boolean) return ToNumber(x) == y if (Type(y) === Boolean) return x == ToNumber(y) if ([String, Number, Symbol].includes(Type(x)) &amp;&amp; Type(y) === Object) return x == ToPrimitive(y) if (Type(x) === Object &amp;&amp; [String, Number, Symbol].includes(Type(y))) return ToPrimitive(x) == y return false // 其他情况均返回false&#125; Type(x) 获取x的类型 ToNumber(x) 将x转换成Number类型 ToBoolean(x) 将x转换成Boolean类型 ToString(x) 将x转换成String类型 ToPrimitive(x) 将x转换成原始值 3. ToPrimitive()方法 - ECMAScript规范中的抽象方法，Javascript不能访问先了解js中的原始类型： Null: null Undefined: undefined Number: 如 0、8、5.5、NaN、Infinite Boolean: true、false String: 如 ‘abc’、’’ 其余都属于’非原始类型’，如 Array、Object、Function typeof null 得到的结果是object, 这是js在设计之初的问题。但null是属于原始类型的（记住就行了🐶） ToPrimitive(input[, hint])转换为原始类型的方法，根据preferedType目标类型进行转换。preferedType只能是 string 或 number 转换步骤： hint 为 number input是原始值，返回input本身 input是对象 先判断input.valueOf()的返回值。如果是原始值，返回结果。 否则，再判断input.toString()的返回值。如果是原始值，返回结果。 否则，抛出不能转换成原始值的TypeError。 hint 为 string input是原始值，返回input本身 input是对象 先判断input.toString()的返回值。如果是原始值，返回结果。 否则，再判断input.valueOf()的返回值。如果是原始值，返回结果。 否则，抛出不能转换成原始值的TypeError。 hint 为空 input 是 Date 日期类型 input被认为是string。 先判断input.toString()的返回值。如果是原始值，返回结果。 否则，再判断input.valueOf()的返回值。如果是原始值，返回结果。 否则，抛出不能转换成原始值的TypeError。 input 是 非Date 类型 input被认为是number。 先判断input.valueOf()的返回值。如果是原始值，返回结果。 否则，再判断input.toString()的返回值。如果是原始值，返回结果。 否则，抛出不能转换成原始值的TypeError。 当调用ToPrimitive而没有传hint参数时，默认情况下hint将被赋值Number。但是可以重写对象的@@toPrimitive方法来覆盖这个行为。在本规范中，只有Date和Symbol两个对象重写了默认的ToPrimitive操作。对于Date对象，如果没有传hint，hint将被默认赋值为String 示例1：ToPrimitive([10])123456// 没有传入hint参数，并且input是Array, 所以hint被赋值为Number// 先判断valueOf()[10].valueOf() 等于 [10]，属于 Array/Object，不是原始类型// 再判断toString()[10].toString() 等于 '10'，属于 String，是原始类型所以 return '10' 示例2：ToPrimitive(function sayHi(){})123456789var sayHi = function (name) &#123; console.log('hi, ' + name)&#125;// 没有传入hint参数，并且input是Function, 所以hint被赋值为Number// 先判断valueOf() typeof sayHi.valueOf === 'function'sayHi.valueOf() 等于 f (name) &#123; console.log('hi, ' + name) &#125; 属于Function，不是原始类型// 再判断toString() typeof sayHi.toString === 'string'sayHi.toString() 等于 function (name) &#123; console.log('hi, ' + name) &#125; 属于String，是原始类型所以 return sayHi方法的方法体源码字符串 上面示例中 [10] == 10 Type(x) === Object, Type(y) === Number，变成比较 ToPrimitive([10]) == 10 由示例1 知道 ToPrimitive([10]) === ‘10’，变成比较 ‘10’ == 10 此时，Type(x) === String, Type(y) === Number，变成比较 ToNumber(‘10’) == 10 ToNumber(‘10’) === 10，变成比较 10 == 10 return true [] == 0 Type(x) === Object, Type(y) === Number, 变成比较 ToPrimitive([]) == 0 没有传入hint参数，[]不属于Date类型，hint被赋值Number Number hint先判断 valueOf()， [].valueOf()返回数组本身，不是原始类型 再判断toString()，[].toString() === ‘’，属于原始类型 return ‘’ 等式变成 ‘’ == 0 此时，Type(x) === String, Type(y) === Number, 变成比较ToNumber(‘’) == 0 ToNumber(‘’) === 0, 变成比较 0 == 0 return true 按照上述步骤推导，不难可以得到： [] == false 返回true那么 ![] == false 应该返回 false吧！ 在控制台验证一下 ![] == false 返回true。纳尼！！ ![] 先转换成 Boolean。 Boolean([]) === true, ![] === false 此时变成 false == false return true 由 [] == false 返回true 和 ![] == false 返回true 得到 [] == ![] 返回 true。 🐶 null == false 走的是最后一步，不满足任何条件，直接返回false，这一说法没有理解。难道不是Type(false) === Boolean然后比较 null == 0么。。。 再就是ToPrimitive(null) == 0 ?? 炸裂，我太难了。 4. toString()方法 可以将除(null和undefined)之外的数据类型转为字符串 123456789101112[].toString() // \"\"[3, 8].toString() // \"3, 8\"new Date().toString() // Fri May 01 2020 14:24:34 GMT+0800 (中国标准时间)\"/abc/ig.toString() // \"/abc/ig\"(16).toString() // '16'(16).toString(2) // '10000' 二进制(2-35都可)(16).toString(8) // '20' 八进制(16).toString(16) // '10' 十六进制0.000006.toString() // '0.000006'0.0000006.toString() // '6e-7' 小数点后面6个或以上0时 小数采用e表示法输出(1234567890123456789012).toString() // '1.2345678901234568e+21' 整数部分超过21位，采用e表示法 可以用toString()区分自定义方法和原生方法123function fn () &#123;&#125;fn.toString() // \"function fn () &#123;&#125;\" -- fn 是自定义方法Number.toString() // \"function Number() &#123; [native code] &#125;\" -- Number是一个原生方法 还可以用Object.prototype上的原生toString()方法判断数据类型12345Object.prototype.toString.call('abc'); // \"[object String]\"Object.prototype.toString.call(123); // \"[object Number]\"Object.prototype.toString.call(true); // \"[object Boolean]\"Object.prototype.toString.call(null) // \"[object Null]\"Object.prototype.toString.call(undefined) //”[object Undefined]\" 判断原生引用类型12345678910111213141516171819202122// 函数类型function fn()&#123;console.log('test')&#125;Object.prototype.toString.call(fn) // \"[object Function]\"// 日期类型var date = new Date()Object.prototype.toString.call(date) // \"[object Date]\"// 数组类型var arr = [1,2,3]Object.prototype.toString.call(arr) // \"[object Array]\"// 正则表达式var reg = /[hbc]at/giObject.prototype.toString.call(reg) // \"[object RegExp]\"// 自定义类型function Person(name) &#123; this.name = name&#125;var person = new Person(\"Rose\")Object.prototype.toString.call(person) // \"[object Object]\" 5. String()方法 如果有toString()方法，则调用该方法，并返回结果 否则： 如果是null，返回”null” 如果是undefined，返回”undefined” 要区分toString()和String() toString(radix)支持传入radix进制参数 toString不支持null和undifined调用 String(null) === ‘null’ String(undifined) === ‘undefined’ 6. Number()方法 布尔值：true - 1 false - 0 数字值：返回数字本身 null：返回0 undefined: 返回NaN 字符串： 只包含数字：转换成十进制，忽略前导0 包含有效的浮点格式：转换成浮点数职，忽略前导0 空字符串：返回0 其他情况：返回NaN 对象：调用对象的valueOf()方法，然后依据前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，再次依照前面的规则转换返回的字符串值。 7. Boolean()方法以下值会被转换为false：false、&quot;&quot;、0、-0、NaN、null、undefined，其余任何值都会被转换为true。另外Boolean()不传递参数时，也返回false。 8. 隐式转换在某些情况下，即使我们不提供显示转换，Javascript也会进行自动类型转换，主要情况有： 8.1 用于检测是否为非数值的函数：isNaN(mix)isNaN()函数，会尝试将参数值用Number()进行转换，如果结果为“非数值”则返回true，否则返回false。 8.2 递增递减操作符（包括前置和后置）、一元正负符号操作符这些操作符适用于任何数据类型的值，针对不同类型的值，该操作符遵循以下规则（经过对比发现，其规则与Number()规则基本相同）： 如果是包含有效数字字符的字符串，先将其转换为数字值（转换规则同Number()），在执行加减1的操作，字符串变量变为数值变量。 如果是不包含有效数字字符的字符串，将变量的值设置为NaN，字符串变量变成数值变量。 如果是布尔值false，先将其转换为0再执行加减1的操作，布尔值变量编程数值变量。 如果是布尔值true，先将其转换为1再执行加减1的操作，布尔值变量变成数值变量。 如果是浮点数值，执行加减1的操作。 如果是对象，先调用对象的valueOf()方法，然后对该返回值应用前面的规则。如果结果是NaN，则调用toString()方法后再应用前面的规则。对象变量变成数值变量。 8.3 加法运算操作符 如果两个操作值都是数值，其规则为： 如果一个操作数为NaN，则结果为NaN 如果是Infinity+Infinity，结果是Infinity 如果是-Infinity+(-Infinity)，结果是-Infinity 如果是Infinity+(-Infinity)，结果是NaN 如果是+0+(+0)，结果为+0 如果是(-0)+(-0)，结果为-0 如果是(+0)+(-0)，结果为+0 如果有一个操作值为字符串，则： 如果两个操作值都是字符串，则将它们拼接起来 如果只有一个操作值为字符串，则将另外操作值转换为字符串，然后拼接起来 如果一个操作数是对象、数值或者布尔值，则调用toString()方法取得字符串值，然后再应用前面的字符串规则。对于undefined和null，分别调用String()显式转换为字符串。 可以看出，加法运算中，如果有一个操作值为字符串类型，则将另一个操作值转换为字符串，最后连接起来。 8.4 乘除、减号运算符、取模运算符这些操作符针对的是运算，所以他们具有共同性：如果操作值之一不是数值，则被隐式调用Number()函数进行转换。具体每一种运算的详细规则请参考ECMAScript中的定义 8.5 逻辑操作符（!、&amp;&amp;、||）逻辑非（！）操作符首先通过Boolean()函数将它的操作值转换为布尔值，然后求反。 逻辑与（&amp;&amp;）操作符，如果一个操作值不是布尔值时，遵循以下规则进行转换： 如果第一个操作数经Boolean()转换后为true，则返回第二个操作值，否则返回第一个值（不是Boolean()转换后的值） 如果有一个操作值为null，返回null 如果有一个操作值为NaN，返回NaN 如果有一个操作值为undefined，返回undefined 逻辑或（||）操作符，如果一个操作值不是布尔值，遵循以下规则： 如果第一个操作值经Boolean()转换后为false，则返回第二个操作值，否则返回第一个操作值（不是Boolean()转换后的值） 对于undefined、null和NaN的处理规则与逻辑与（&amp;&amp;）相同 8.6 关系操作符（&lt;, &gt;, &lt;=, &gt;=） 如果两个操作值都是数值，则进行数值比较 如果两个操作值都是字符串，则比较字符串对应的字符编码值 如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较 如果一个操作数是对象，则调用valueOf()方法（如果对象没有valueOf()方法则调用toString()方法），得到的结果按照前面的规则执行比较 如果一个操作值是布尔值，则将其转换为数值，再进行比较 注：NaN是非常特殊的值，它不和任何类型的值相等，包括它自己，同时它与任何类型的值比较大小时都返回false。 8.7 相等操作符相应规则见文章最初始。 9. 位运算符9.1 按位与(&amp;)9.2 按位与(|)9.3 按位非(~)9.4 按位异或(^)9.5 左移(&lt;&lt;) 该操作符会将左边操作数向左移动右边操作数的位数。向左被移出的位被丢弃，右侧用 0 补充。3 &lt;&lt; 2 = 3 * 2 ^ 2 = 12 9.6 有符号右移(&lt;&lt;) 该操作符会将左边操作数向右移动右边操作数的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。12 &gt;&gt; 2 = 12 / 2 ^ 2 = 3 9.6 无符号右移(&lt;&lt;&lt;) 该操作符会将左边操作数向右移动右边操作数的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。） 10. 参考文章 文章一 文章二 文章三","comments":true,"tags":[{"name":"==","slug":"","permalink":"https://JnathanCoder.github.io/tags//"},{"name":"===","slug":"","permalink":"https://JnathanCoder.github.io/tags//"},{"name":"操作符","slug":"操作符","permalink":"https://JnathanCoder.github.io/tags/操作符/"},{"name":"转换","slug":"转换","permalink":"https://JnathanCoder.github.io/tags/转换/"}]},{"title":"数据类型转换","date":"2020-04-18T16:00:00.000Z","path":"2020/04/19/data-type-transfer/","text":"基本数据类型有 Number、 String、 Boolean、 Null、 Undefined、Object，ES6新增了Symbol 类型。 1. 原始值转布尔在Javascript中。只有6种值可以被转换成false，其余均为true：false、undefined、null、NaN、0、&#39;&#39; 12345678console.log(Boolean(false)) // falseconsole.log(Boolean(undefined)) // falseconsole.log(Boolean(null)) // falseconsole.log(Boolean(NaN)) // falseconsole.log(Boolean(0)) // falseconsole.log(Boolean('')) // false// Boolean不传任何参数时 返回falseconsole.log(Boolean()) // false 2. 原始值转数字使用Number函数将数据转换成数字类型，参数无法转换成数字的，返回NaN。根据规范，如果Number函数不传参数，返回0，如果有参数，调用toNumber(value),其对应结果如下： 参数类型 结果 undefined NaN null 0 布尔值 true: 1, false: 0 Number 对应的值 String 比较复杂，看具体例子 12345678910111213141516171819console.log(Number()) // 0console.log(Number(undefined)) // NaNconsole.log(Number(null)) // 0console.log(Number(true)) // 1console.log(Number(false)) // 0console.log(Number(88)) // 88console.log(Number(\"123\")) // 123console.log(Number(\"-123\")) // -123console.log(Number(\"1.2\")) // 1.2console.log(Number(\"000123\")) // 123console.log(Number(\"-000123\")) // -123console.log(Number(\"0x11\")) // 17console.log(Number(\"\")) // 0console.log(Number(\" \")) // 0console.log(Number(\"123 123\")) // NaNconsole.log(Number(\"foo\")) // NaNconsole.log(Number(\"100a\")) // NaN 如果通过 Number 转换函数传入一个字符串，它会试图将其转换成一个整数或浮点数，而且会忽略所有前导的 0，如果有一个字符不是数字，结果都会返回 NaN。如果字符串前缀是0x或者0X，将转换为十六进制数。 3. 原始值转字符使用 String 函数将类型转换成字符串类型。根据规范，如果不传递参数，返回空字符串，如果有参数，调用toString(value)，其对应结果如下： 参数类型 结果 undefined “undefined” null “null” Boolean true: “true”, false: “false” Number 比较复杂，看具体例子 String 对应的值 1234567891011121314console.log(String()) // 空字符串console.log(String(undefined)) // undefinedconsole.log(String(null)) // nullconsole.log(String(false)) // falseconsole.log(String(true)) // trueconsole.log(String('678')) // 678console.log(String(0)) // 0console.log(String(-0)) // 0console.log(String(NaN)) // NaNconsole.log(String(Infinity)) // Infinityconsole.log(String(-Infinity)) // -Infinityconsole.log(String(1)) // 1 注意这里的 ToString 和上一节的 ToNumber 都是底层规范实现的方法，并没有直接暴露出来。 4. 对象转字符串和数字几种基本数据类型中，除了Null和Undefined类型外，其余5种原型链上都有valueOf()和toString()函数。这两个函数主要在隐式类型转换时会被自动调用。 4.1 同时重写对象的toString方法和valueOf方法1234567891011121314151617181920212223var aaa = &#123; i: 10, valueOf: function() &#123; console.log('调用valueOf...') return this.i + 30 &#125;, toString: function() &#123; console.log('调用toString...') return this.i + 10 &#125;&#125;console.log(aaa &gt; 20); // 调用valueOf... trueconsole.log('' + aaa); // 调用valueOf... 40console.log(++aaa); // 调用valueOf... 41// 在不执行上一步 console.log(++aaa) 的前提console.log(+aaa); // 调用valueOf... 40// 在执行上一步 console.log(++aaa) 的前提 此时aaa变成了字符串41console.log(+aaa); // 41 调用原型链上默认的valueOf()console.log(aaa == 40) // 调用valueOf... true// 上面的步骤没执行的前提下 否则aaa变成了字符串41 此时输出41console.log(aaa); // &#123;i: 10, valueOf: ƒ, toString: f&#125;console.log(String(aaa)) // 调用toString... 20 总结：涉及到操作符的问题，valueOf的优先级更高；涉及到显示问题，toString方法优先级更高。 4.2 只重写toString方法12345678910111213141516171819var bbb = &#123; i: 10, toString: function() &#123; console.log('调用toString...') return this.i + 10 &#125;&#125;console.log(bbb &gt; 20); // 调用toString... falseconsole.log('' + bbb); // 调用toString... 20console.log(++bbb); // 调用toString... 21// 在不执行上一步 console.log(++bbb) 的前提console.log(+bbb); // 调用toString... 20// 在执行上一步 console.log(++bbb) 的前提 此时bbb变成了字符串21console.log(+bbb); // 21 调用原型链上默认的valueOf()console.log(bbb == 20) // 调用toString... true// console.log(bbb); // &#123;i: 10, toString: ƒ&#125; 没调用重写的toString()方法，调用了原型链上默认的valueOf()console.log(String(bbb)) // 调用toString... 20 总结： toString方法比原型链上的valueOf方法优先级高","comments":true,"tags":[{"name":"数据类型","slug":"数据类型","permalink":"https://JnathanCoder.github.io/tags/数据类型/"},{"name":"类型转换","slug":"类型转换","permalink":"https://JnathanCoder.github.io/tags/类型转换/"}]},{"title":"移动端真机调试 spy-debugger","date":"2019-07-15T08:53:26.000Z","path":"2019/07/15/spy-debugger/","text":"关于spy-debugger一站式页面调试、抓包工具。远程调试任何手机浏览器页面，任何手机移动端webview（如：微信，HybridApp等）。支持HTTP/HTTPS，无需USB连接设备。 特性1、页面调试＋抓包2、操作简单，无需USB连接设备3、支持HTTPS。4、spy-debugger内部集成了weinre、node-mitmproxy、AnyProxy。5、自动忽略原生App发起的https请求，只拦截webview发起的https请求。对使用了SSL pinning技术的原生App不造成任何影响。6、可以配合其它代理工具一起使用(默认使用AnyProxy) (设置外部代理) 安装1[sudo] npm install spy-debugger -g 三分钟上手第一步：手机和PC保持在同一网络下（比如同时连到一个Wi-Fi下）第二步：命令行输入spy-debugger，按命令行提示用浏览器打开相应地址。第三步：设置手机的HTTP代理，代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)。 Android设置代理步骤：设置 - WLAN - 长按选中网络 - 修改网络 - 高级 - 代理设置 - 手动iOS设置代理步骤：设置 - 无线局域网 - 选中网络 - HTTP代理手动 第四步：手机安装证书。 spy-debugger initCA 会将证书放置到系统根目录node-mitmproxy文件夹。Mac 如：/users/yourName/node-mitmproxyWindows 如：C/users/yourName/node-mitmproxy将文件夹下的node-mitmproxy.ca.crt到手机上安装 第五步：用手机浏览器访问你要调试的页面即可。 效果截图 自定义选项端口(默认端口9888)1spy-debugger -p 9999 设置外部代理（默认使用AnyProxy）1spy-debugger -e http://127.0.0.1:8888 设置页面内容为可编辑模式（默认false）1spy-debugger -w true 该功能使页面内容修改更加直观方便。内部实现原理：在需要调试的页面内注入代码：document.body.contentEditable=true。暂不支持使用了iscroll框架的页面。 是否允许weinre监控iframe加载的页面(默认false)1spy-debugger -i true 是否只拦截浏览器发起的https请求（默认true）1spy-debugger -b false 是否允许HTTP缓存(默认false)1spy-debugger -c true","comments":true,"tags":[]},{"title":"知识点","date":"2019-06-06T08:48:44.000Z","path":"2019/06/06/brief-info/","text":"1. 一些js插件为什么以;开头因为js代码允许在结束的时候不添加;, 所以两个js文件在合并拼接的的时候可能出错。 12345678// a.js// 末尾没有添加;符号var a = 'test'// b.js(function()&#123; // do something&#125;)(); 以上两个文件进行合并压缩的时候就可能变为： 123var a = 'test'(function()&#123;&#125;)();// 这样会报错： TypeError: 'test' is not a function 2. 使用闭包定义私有属性123456789101112131415161718function Product() &#123; var name; this.setName = function(value) &#123; name = value; &#125;; this.getName = function() &#123; return name; &#125;;&#125;var p = new Product();p.setName(\"test\");console.log(p.name); // 输出undefinedconsole.log(p.getName()); // 输出test 代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。 3. 枚举属性 可枚举性在js中，基本数据类型的原型属性是不可枚举的，比如Object、Array、Number等。 12345// 打印结果为空 Number内置属性是不可枚举的var num = new Number()for (let i in num) &#123; console.log(i, num[i])&#125; propertyIsEnumerable Object.propertyIsEnumerable(prop)prop 需要测试的属性名返回值 用来表示指定的属性名是否可枚举的Boolean属性必须满足 自身属性 &amp;&amp; 枚举属性，才会返回true 1234567var obj = &#123;&#125;obj.test = 'Jnathan'var arr = [23, 67]obj.propertyIsEnumerable('test') // truearr.propertyIsEnumerable(0) // truearr.propertyIsEnumerable(1) // true hasOwnProperty Object.hasOwnProperty(prop)prop 需要测试的属性名返回值 用来表示指定的属性名是否在对象中的Boolean 1234567var obj = &#123;&#125;obj.x = 'Jnathan'obj.y = function() &#123;&#125;obj.hasOwnProperty('x') // trueobj.hasOwnProperty('y') // true 方法也属于属性obj.hasOwnProperty('z') // false 属性不存在obj.hasOwnProperty('toString') // false toString是继承的Object中的属性，obj自身属性中不包含 123456789101112function Person() &#123; this.name = 'Jnathan'&#125;Person.prototype = &#123; constructor: Person, job: 'student',&#125;var Jnathan = new Person()Object.defineProperty(Jnathan, \"gender\", &#123; value: 'female', enumerable: false&#125;) 以上， 用defineProperty为对象Jnathan定义了一个名为gender的不可枚举属性 枚举 for…in 123456789101112131415161718192021222324for (let item in Jnathan) &#123; console.log('Jnathan.' + item + ' = ' + Jnathan[item])&#125;// Jnathan.name = Jnathan// Jnathan.constructor = function Person() &#123;// this.name = 'Jnathan'// &#125;// Jnathan.job = studentfunction enumer() &#123; this.a = '我是对象本身就有的属性'&#125;enumer.prototype.b = '我是通过原型对象挂载的属性'let fn = new enumer()Object.defineProperty(fn, 'c', &#123; value: '我是通过Object.defineProperty方法添加的可枚举属性', enumerable: true&#125;);for(let item in fn) &#123; console.log(item)&#125;// a// b// c 枚举 Object.keys() 1234567891011121314Object.keys(Jnathan)// [\"name\"]function enumer() &#123; this.a = '我是对象本身就有的属性'&#125;enumer.prototype.b = '我是通过原型对象挂载的属性'let fn = new enumer()Object.defineProperty(fn, 'c', &#123; value: '我是通过Object.defineProperty方法添加的可枚举属性', enumerable: true&#125;);console.log(Object.keys(fn))// [\"a\", \"c\"] 枚举 JSON.stringify() 1234567891011121314JSON.stringify(Jnathan)// \"&#123;\"name\":\"Jnathan\"&#125;\"function enumer() &#123; this.a = '我是对象本身就有的属性'&#125;enumer.prototype.b = '我是通过原型对象挂载的属性'let fn = new enumer()Object.defineProperty(fn, 'c', &#123; value: '我是通过Object.defineProperty方法添加的可枚举属性', enumerable: true&#125;)console.log(JSON.stringify(fn))// &#123;\"a\":\"我是对象本身就有的属性\",\"c\":\"我是通过Object.defineProperty方法添加的可枚举属性\"&#125; 根据现象有以下总结for…in 可以枚举对象本身具有的属性，通过Object.defineProperty()方法加的可枚举属性，或者通过原型对象绑定的可以枚举属性Object.keys() 可以枚举对象本身的属性和通过Object.defineProperty()添加的可枚举属性JSON.stringify() 可以枚举对象本身的属性和通过Object.defineProperty()添加的可枚举属性，并序列化为JSON字符串 !== undefined 1234567var obj = &#123;x: 1, y: undefined, z: null&#125;console.log(obj.x !== undefined) // true 属性存在console.log(obj.y !== undefined) // false 此时会出现歧义，不能准确判断属性是不存在还是属性值本身就为undefinedconsole.log(obj.z !== undefined) // true 属性存在console.log(obj.z != undefined) // false != 不能区分undefined和null，将两者同等对待console.log(obj.w !== undefined) // false 属性不存在console.log(obj.toString !== undefined) // true 存在toString函数属性。 in 自身存在的属性或者继承的属性均返回true 123456var obj = &#123;x: 1, y: undefined, z: null&#125;console.log(\"x\" in obj) // true 属性存在console.log(\"y\" in obj) // true 属性存在console.log(\"z\" in obj) // true 属性存在console.log(\"w\" in obj) // false 属性不存在console.log(\"toString\" in obj) // true 属性存在 Object.defineProperty() 参数：Object.defineProperty(object, propertyname, descriptor)object 必需。 要在其上添加或修改属性的对象。 这可能是一个本机 JavaScript 对象（即用户定义的对象或内置对象）或 DOM 对象。propertyname 必需。 一个包含属性名称的字符串。descriptor 必需。 属性描述符。 它可以针对数据属性或访问器属性。返回值：已修改对象 当对象不具有指定的属性名称时，向对象添加新属性。当对象已具有指定的属性名称时，修改现有属性的特性。 12345678910var obj = &#123;&#125;Object.defineProperty(obj, \"newDataProperty\", &#123; value: 101, writable: false, enumerable: false, configurable: true&#125;);obj.newDataProperty = 102console.log(obj.newDataProperty) // 101 whiteable为false 只读，不能修改 Object.getOwnPropertyNames 由于obj的属性newDataProperty是不可枚举的，使用for…in不能找到newDataProperty属性 123for (let item in obj) &#123; console.log(item, obj[item]) // 无输出&#125; 此时可以使用Object.getOwnPropertyNames来遍历 12345var names = Object.getOwnPropertyNames(obj)for (let i = 0; i &lt; names.e]length; names++) &#123; console.log(names, i, names[i])&#125;// [\"newDataProperty\"] 0 newDataProperty 12345678910111213141516171819var obj = &#123;&#125;Object.defineProperty(obj, \"newAccessorProperty\", &#123; set: function (x) &#123; console.log(\"in property set accessor\"); this.newaccpropvalue = x; &#125;, get: function () &#123; console.log(\"in property get accessor\"); return this.newaccpropvalue; &#125;, enumerable: true, configurable: true&#125;);obj.newAccessorProperty = 30console.log(\"Property value: \" + obj.newAccessorProperty)// in property set accessor// in property get accessor// Property value: 30 修改DOM上的属性 12Object.getOwnPropertyDescriptor(Element.prototype, \"querySelector\")// &#123;value: ƒ, writable: true, enumerable: true, configurable: true&#125; 1234567891011var descriptor = Object.getOwnPropertyDescriptor(Element.prototype, \"querySelector\")descriptor.value = \"query\"descriptor.writable = falseObject.defineProperty(Element.prototype, \"querySelector\", descriptor)var elem = document.getElementById(\"div\")elem.querySelector = \"anotherQuery\" // whitable 为false 更改不生效console.log(elem.querySelector) // query","comments":true,"tags":[]},{"title":"日志内容【二】","date":"2019-05-26T06:08:31.000Z","path":"2019/05/26/multiple-diary2/","text":"1. substr() 和 substring() substr stringObject.substr(startIndex[, length]) 12345678var str = ‘abcdefg'str.substr(2) // ‘cdefg’str.substr(-1) =&gt; str.substr(6) // ‘fg’str.substr(6) // ‘'str.substr(2,2) // ‘cd’str.substr(2,7) // ‘cdefg’str.substr(2,-1) // '' substring stringObject.substring(startIndex[, stop]) 注意stop的含义 1234567var str = ‘abcdefg'str.substring(2) // ‘cdefg’str.substring(2,4) // ‘cd’str.substring(2,9) // ‘cdefg’str.substring(-2) =&gt; str.substring(0) // ‘abcdefg’str.substring(2,-4) =&gt; str.substring(2,0) =&gt; str.substring(0,2) // ‘ab' 2. slice() 和 splice() slice stringObject.slice(startIndex[, stop])arrayObject.slice(startIndex[, stop])stop 缺省时 默认一直到最后 12345678910111213var str = ‘abcdefg’str.slice(2) // ‘cdefg'str.slice(0) // ‘abcdefg’str.slice(-2) =&gt; str.slice(5) // ‘fg’str.slice(8) // ‘’ 空串 str.slice(2,4) // ‘cd’str.slice(2,6) // ‘cdef’str.slice(2,18) // ‘cdefg’str.slice(4,2) // ‘’ 空串str.slice(4,-1) =&gt; str.slice(4,6) // ‘ef’// 数组方法类似 splice arrayObject.splice(startIndex, length[, item1, item2…])splice操作会改变原数组 返回被移除的元素数组 12345678var arr = [‘a’,’b’,’c’,’d’,’e’,’f’,’g’]arr.splice(2,0) // 空数组 arr = [‘a’,’b’,’c’,’d’,’e’,’f’,’g’]arr.splice(2,8) // arr = [‘a’, ‘b’, ‘c']arr.splice(2,-5) // 返回arr arr没有变化arr.splice(8,2) // 返回arr arr没有变化arr.splice(2,2,'11',’22') // 返回[‘a’, ‘b’, ’11’, ’22’, ‘e’, ‘f’, ‘g’] arr = [‘c’, ‘d'] 3. 检测数据类型 typeof typeof 是解释器内部实现，根据 ECMA-262 规定的几种类型的值来返回类型名称。但是 typeof 的应用场景非常有限，基本上只能判断出来使用字面量方式赋值的基本数据类型。 12345678910typeof 23 // numbertypeof '124' // stringtypeof true // booleantypeof undefined // undefinedtypeof &#123;&#125; // objecttypeof null // objecttypeof [1, 3, 8] // objecttypeof function fn () &#123;&#125; // functiontypeof (new Number(33)) // objecttypeof (new String('hello')) // object 从上面例子可以看出， typeof 检测出来的类型不够准确，具有相当大的局限性。 instanceof instance 检测类型的原理大致为: 判断左边的对象的隐式原型 proto 是否和右边对象的显式原型 prototype 相等。 很像 new 操作，这样就可以判断指定的某个对象是否为某个构造函数的实例。 instance 的局限性应该是不能检测基本数据类型。另外一点，不同 window 或者 iframe 之间对象类型检测不能使用 instanceof 来检测。 1234567'123' instance String // falseNumber instanceof Number // truenew String('hello') instance String // truenew Number(33) instance Number // true Object.prototype.toString 1234567891011121314151617Object.prototype.toString.call(33) // [object Number]Object.prototype.toString.call('hello') // [object String]Object.prototype.toString.call([]) // [object Array]Object.prototype.toString.call(&#123;&#125;) // [object Object]Object.prototype.toString.call(true) // [object Boolean]Object.prototype.toString.call(null) // [object null]Object.prototype.toString.call(undefined) // [object undefined]Object.prototype.toString.call(function fn () &#123;&#125;) // [object Function]Object.prototype.toString.call(new Number(33)) // [object Number] constructor constructor 属性返回对创建此对象的数组函数的引用。constructor 不能检测出null和undefined两种，会报错。 1234567891011121314151617181920(33).constructor == Number // true('hello'.constructor == String // true([]).constructor == Array // true(&#123;&#125;).constructor == Object // true(true).constructor == Boolean // true(null).constructor == null // TypeError: Cannot read property 'constructor' of null(undefined).constructor == undefined // TypeError: Cannot read property 'constructor' of undefinedvar fn = function () &#123;&#125;fn.constructor == Function // truevar number = new Number(66)number.constructor == Number // truenumber.constructor == Object // false 我是分割线 Array.isArray() 4. ES5 Array Function forEach Array.forEach(callbackFn[, thisObj])callbackFn (value, index, arr)thisObj 默认为 window 123[1, 2, 5, 8].forEach( function (ele, index, arr) &#123; console.log(ele, index, arr)&#125;) map Array.map(callbackFn[, thisObj])callbackFn (value, index, arr) 123[1, 2, 5, 8].map(function (ele, index, arr) &#123; return ele * index // [0, 2, 10, 24]&#125;) filter Array.filter(callbackFn[, thisObj])callbackFn (value, index, arr), 需要返回 Boolean 值 1234567[0, 2, 5, 8].filter(function (ele, index, arr) &#123; return ele // [2, 5, 8]&#125;)[0, 2, 5, 1].filter(function (ele, index, arr) &#123; return ele &lt;= index // [0, 1]&#125;) some Array.some(callbackFn[, thisObj])callbackFn (value, index, arr) 123[1, 2, 5, 8].some(function (ele, index, arr) &#123; return ele &gt; 5 // true (8 &gt; 5)&#125;) every Array.every(callbackFn[, thisObj])callbackFn (value, index, arr) 123[1, 2, 5, 8].every(function (ele, index, arr) &#123; return ele &gt; 5 // false (1, 2, 5 均不大于5)&#125;) indexOf Array.indexof(searchEle[, fromIndex])第一个出现的 searchEle 的索引位置searchEle 要查找的元素fromIndex 开始查找的索引位置，缺省或不符合规范时为 0 1234[1, 2, 5, 8].indexOf(2) // 1[1, 2, 5, 8].indexOf(2, '0') // 1[1, 2, 5, 8].indexOf(2, 'f') =&gt; [1, 2, 5, 8].indexOf(2, 0) // 1[1, 2, 5, 8].indexOf(2, 2) // -1 lastIndexOf Array.lastIndexOf(searchEle[, fromIndex])与 indexOf 不同在于此方法是从后面元素开始查找的searchEle 要查找的元素fromIndex 开始查找的索引位置，缺省时或大于等于 Array.length 为 Array.length - 1 123456[1, 2, 5, 8, 5].lastIndexOf(5) // 4[1, 2, 5, 8, 5].lastIndexOf(5, 4) // 4[1, 2, 5, 8, 5].lastIndexOf(5, 8) =&gt; [1, 2, 5, 8, 5].lastIndexOf(5, 4) // 4[1, 2, 5, 8, 5].lastIndexOf(5, 'f') // -1[1, 2, 5, 8, 5].lastIndexOf(5, 3) // 2[1, 2, 5, 8, 5].lastIndexOf(5, 1) // -1 reduce Array.reduce(callbackFn[, initValue])callbackFn(previous, current, index, arr)previous 前一次迭代计算出来的值current 当前迭代的值initValue 初始值, 未指定时取数组的第一个元素 123[1, 2, 5, 8].reduce(function (preV, curV, index, arr) &#123; return preV + curV&#125;, 10) // 26 123456789101112131415// 梳理一下计算过程：// 初始化的时候preV = initValue = 10, curV = 1, index = 0// 第一次计算preV = 10 + 1 = 11, curV = 2, index = 1// 第二次计算preV = 11 + 2 = 13, curV = 5, index = 2// 第三次计算preV = 13 + 5 = 18, curV = 8, index = 3// 第四次计算preV = 18 + 8 = 26, curV = undefined (退出) reduceRight 和 reduceRight 用法基本一致，不过是从数组后面开始迭代的Array.reduceRight(callbackFn[, initValue])callbackFn(previous, current, index, arr)previous 前一次迭代计算出来的值current 当前迭代的值 123456[1, 2, 5, 8].reduceRight(function (preV, curV, index, arr) &#123; if (index == 0) &#123; return preV - curV &#125; return preV + curV&#125;, 10) // 24 123456789101112131415// 梳理一下计算过程：// 初始化的时候preV = initValue = 10, curV = 8, index = 3// 第一次计算preV = 10 + 8 = 18, curV = 5, index = 2// 第二次计算preV = 18 + 5 = 23, curV = 2, index = 1// 第三次计算preV = 23 + 2 = 25, curV = 1, index = 0// 第四次计算preV = 25 - 1 = 24, curV = undefined (退出) 参考文章","comments":true,"tags":[]},{"title":"webpack-study","date":"2019-05-23T07:29:00.000Z","path":"2019/05/23/webpack-study/","text":"webpack-dev-server-312345678910111213141516171819var devMiddleware = require('webpack-dev-middleware')(compiler, &#123; publicPath: webpackConfig.output.publicPath, hot: true, stats: &#123; colors: true, chunks: false &#125;&#125;)// use expressapp.use(devMiddleware)app.listen(port, host, function (err) &#123; if (err) &#123; console.log(err) return &#125; console.log('Listening at ' + host + ':' + port + '\\n')&#125;) CommonsChunkPlugin123456789101112131415161718192021// webpack.config.jsvar webpack = require(‘webpack’)entry: &#123; vendor: ['jquery', 'lodash'], vuecore: './vuecore.js'&#125;, plugins: [ // new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.bundle.js'), // new webpack.optimize.CommonsChunkPlugin(&#123; // name: 'vuecore', // filename: 'vuecore.js' // &#125;), // Error: CommonsChunkPlugins: While running in normal mode its not allowed to use a non-entry chunk (vuecore) // doing this instaed new webpack.optimize.CommonsChunkPlugin(&#123; names: ['vuecore','vendor'] &#125;), new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.bundle.js')]","comments":true,"tags":[{"name":"webpack","slug":"webpack","permalink":"https://JnathanCoder.github.io/tags/webpack/"}]},{"title":"日志内容【一】","date":"2019-05-22T09:43:43.000Z","path":"2019/05/22/multiple-diary/","text":"1. setTimeout中方法体添加引号与不添加引号的区别 添加引号的情况，调用的函数是全局范围的。未添加引号的情况，调用的是局部范围的。 1234567891011121314151617var testFn = function () &#123; console.info('hello from global')&#125;var fn = function () &#123; var testFn = function () &#123; console.info('hello fron inner') &#125; setTimeout('testFn()', 1000) // hello form global setTimeout(testFn, 1000) // hello from inner // 在fn()函数内部没有定义testFn的时候，会向上寻找testFn，这里找到了全局函数，执行效果： setTimeout(testFn, 1000) // hello from global&#125;fn() 2. AMD/CMD规范 common.jscommon.js 运行在服务器端，因为模块就在磁盘上，所以加载时间几乎可以忽略不计，属于同步加载。 [典型代表 node.js]AMD与CMD都属于异步加载，运行在浏览器端。AMD 推崇依赖前置，定义模块的时候就需要申明需要依赖的模块 [典型代表 require.js]CMD 推崇依赖就近，需要用到的时候才去require相关模块 [典型代表 sea.js] 3. stopPropagation() 以及 stopImmediatePropagation()stopImmediatePropagation 用于阻止冒泡，在执行完当前元素上的事件处理程序之后，停止当前元素以及后续元素的事件处理程序 stopPropagation 同样也是用于阻止冒泡，在执行完绑定到当前元素上的所有事件处理程序之后，停止后续元素的事件处理程序 同一个元素用on绑定多次同样事件时（例如click），最后一次会覆盖之前的事件，不会执行前面。而用addEventListener绑定多次同样事件时，都会执行。 12345&lt;div id=\"large\" style=\"width: 150px; height: 150px; background: orange\"&gt; &lt;div id=\"middle\" style=\"width: 100px; height: 100px; background: cadetblue\"&gt; &lt;div id=\"small\" style=\"width: 50px; height:50px; background: coral\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546(function()&#123; var large = document.getElementById('large') var middle = document.getElementById('middle') var small = document.getElementById('small') large.addEventListener('click', function()&#123; alert('large div is clicked') &#125;) middle.addEventListener('click', function()&#123; alert('middle div is clicked') &#125;) // 第一种情况： 点击small时，会依次弹出三个窗口，这是因为向上冒泡产生的 small.addEventListener('click', function()&#123; alert('small div is clicked') &#125;) // 第二种情况： 点击small时，会弹出四个窗口 // small.addEventListener('click', function()&#123; // alert('small-1 is clicked') // &#125;) // small.addEventListener('click', function()&#123; // alert('small-2 is clicked') // &#125;) // 第三种情况，添加stopPropagation： 点击small时，会弹出两个窗口 // small-1 is clicked small-2 is clicked // small.addEventListener('click', function(event)&#123; // alert('small-1 is clicked') // event.stopPropagation() // &#125;) // small.addEventListener('click', function()&#123; // alert('small-2 is clicked') // &#125;) // 第四种情况，添加stopImmediatePropagation： 点击small时，会弹出一个窗口 // small-1 is clicked // 能够很明显看到与stopPropagation的区别，调用stopImmediatePropagation之后，第二个定义的click事件也被取消而不被执行了。 // small.addEventListener('click', function(event)&#123; // alert('small-1 is clicked') // event.stopImmediatePropagation() // &#125;) // small.addEventListener('click', function()&#123; // alert('small-2 is clicked') // &#125;)&#125;)() (function(){ var large = document.getElementById('large') var middle = document.getElementById('middle') var small = document.getElementById('small') large.addEventListener('click', function(){ alert('large div is clicked') }) middle.addEventListener('click', function(){ alert('middle div is clicked') }) // 第一种情况： 点击small时，会依次弹出三个窗口，这是因为向上冒泡产生的 small.addEventListener('click', function(){ alert('small div is clicked') }) // 第二种情况： 点击small时，会弹出四个窗口 // small.addEventListener('click', function(){ // alert('small-1 is clicked') // }) // small.addEventListener('click', function(){ // alert('small-2 is clicked') // }) // 第三种情况，添加stopPropagation： 点击small时，会弹出两个窗口 // small-1 is clicked small-2 is clicked // small.addEventListener('click', function(event){ // alert('small-1 is clicked') // event.stopPropagation() // }) // small.addEventListener('click', function(){ // alert('small-2 is clicked') // }) // 第四种情况，添加stopImmediatePropagation： 点击small时，会弹出一个窗口 // small-1 is clicked // 能够很明显看到与stopPropagation的区别，调用stopImmediatePropagation之后，第二个定义的click事件也被取消而不被执行了。 // small.addEventListener('click', function(event){ // alert('small-1 is clicked') // event.stopImmediatePropagation() // }) // small.addEventListener('click', function(){ // alert('small-2 is clicked') // }) })() 4. js事件中的三个阶段三个阶段分别为捕获阶段 目标阶段 冒泡阶段element.addEventListener(type, fn[, useCapture])useCapture - 指定事件句柄在捕获阶段或者冒泡阶段执行， 默认false(事件句柄在冒泡阶段执行)，设置为true(事件句柄在捕获阶段执行)。 捕获阶段 目标阶段 冒泡阶段 5. 常见的前端性能优化手段 css sprites（雪碧图） 避免使用css表达式 css样式表放在页面顶部，脚本放在页面底部 内联图片和脚本使用data:URL（base64编码）模式直接包含在页面中，无需进行http请求，缺点：ie不支持，图片太大不适用，使用base64会增加页面体积，浏览器不会缓存 使用内容分发网络CDN 开启GZIP压缩，启用负载均衡 开启keep alive减少与服务器链接次数 缺点：使服务器负载增大，也更容易遭受攻击 精简压缩代码 uglifyjs 避免重定向 常见的301 302 配置e-tags 和 expires头 使用缓存 按需加载资源 6. parseInt() 以及 parseFloat() parseInt(string[, radix]) string如果以‘ox’或者’oX’开头，将以16进制进行解析 radix 要解析的数字基数，介于2-36之间 如果不给值或者为0，则按照基数为10来计算 如果小于2或者大于36，则返回NaN 开头和结尾的空格是允许的 如果字符串的第一个字符不能转换成对应的数字，将返回NaN 12345678910111213141516171819parseInt('0x12') // 17parseInt('0x12', 2) // 0 =&gt; parseInt('0', 2)parseInt('0x12', 10) // 0 =&gt; parseInt('0', 16)parseInt('8') // =&gt; parseInt('8', 0) =&gt; parseInt('8', 10) // 8parseInt('8', 1) // NaNparseInt('8', 37) // NaNparseInt('a23') // NaNparseInt('2a3') // 2parseInt(' 23') // 23parseInt(' 23 ') // 23parseInt(' 2 3 ') // 2parseInt('11', 2) // 3parseInt(11, 2) // 3parseInt('1100', 2) // 12parseInt('21', 2) // NaN 2超出了2进制最大值1，并且是第一个字符parseInt('12', 2) // 1 2同样超出了2进制最大值1，但是第一个字符可以转换成二进制parseInt('66', 8) // 6*8^1 + 6*8^0 = 48 + 6 = 54parseInt('12', 16) // 1*16^1 + 2*16^0 = 16 + 2 = 18[0, 1, 2, 3].map(parseInt) // [parseInt(0, 0), parseInt(1, 1), parseInt(2, 2), parseInt(3, 3)] =&gt; [0, NaN, NaN, NaN] parseFloat() parseInt(string[, radix]) 这里语法待修改 开头和结尾的空格是允许的 如果字符串的第一个字符不能转换成对应的数字，将返回NaN 如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符 7. charAt()、charCodeAt() 和 fromCharCode() charAt() String.charAt(index) 返回字符串中指定位置的字符, 索引值 index &lt; 0 或超出了范围则返回一个空字符串 123'abc'.charAt(1) // 'b''abc'.charAt(-2) // '''abc'.charAt(5) // '' charCodeAt() String.charCodeAt(index) 返回字符串中指定位置的字符的 unicode 数值 [0, 1114111] 开头的 128 个 unicode 编码单元和 ASCII 字符编码一样 索引值 index &lt; 0 或超出了范围则返回一个 NaN, 大于 255 的是中文 12345'AabcdD'.charCodeAt(0) // 65'AabcdD'.charCodeAt(1) // 97'AabcdD'.charCodeAt(-1) // NaN'AabcdD'.charCodeAt(8) // NaN'中国'.charCodeAt(1) // 22269 fromCharCode() String.fromCharCode(num1, num2, num3, …) 根据指定的 unicode 编码中的序号值来返回字符串 1String.fromCharCode(65, 66, 97) // 'ABa' 8. 原生ajax12345678910var xhr = new XMLHttpRequest()// 请求方式 请求路径 是否异步发送请求xhr.open('GET', 'http://www.jnathan.cn/jnathan/effect/authKit.js', true)xhr.send('hello world') xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // alert(xhr.responseText) &#125;&#125; 9. 有一个长度为n的数组，假定全部为整数，其中有且仅有一个数出现了奇数次，其他的数字都出现偶数次，找出出现了奇数次的那个数字。 时间复杂度为O(n) 空间复杂度O(1)利用了n ^ n = 0, n ^ 0 = n两个等式的原理。循环对数组数字进行异或计算，即 0 ^ arr[0] ^ arr[1] ^ ... ^ arr[n - 1] ，异或计算满足交换律原则，如果数组元素出现了相同的情况，可以移动到一起先进行计算，如果出现了偶数次，其结果为 0，出现了奇数次的数其结果为该数字，所以表达式最后得出来的结果即为数组所有出现了奇数次元素的异或操作的结果。比如：[1,2,2,3,4,4]进行异或操作得到的结果是 1 ^ 3 = 2 ，特殊情况下（只有一个数字出现了奇数次），那么最后的结果就是出现了奇数次的那个数字！！ 123456789function fn7 (arr) &#123; var oddTimesNumber = 0 for (let i in arr) &#123; oddTimesNumber = oddTimesNumber ^ arr[i] &#125; return oddTimesNumber&#125;fn7([1,2,3,4,5,4,4,3,2,1,1,1]) // 3 10. 递归求1-10的和123456789101112function getSum(nextArr, curSum = 0) &#123; var sum = nextArr[0] + curSum if (nextArr.length == 1) &#123; return sum &#125; else &#123; return getSum(nextArr.slice(1), sum) &#125;&#125;getSum([1,2,3,4,5,6,7,8,9,10]) 11. 去除数组重复元素 直接双层循环比较 123456789101112131415161718192021222324function unique (arr) &#123; var result = [] var isRepeat for (var i = 0; i &lt; arr.length; i++) &#123; isRepeat = false // 默认不重复，进行push操作，当判断重复时不操作 for (var j = 0; j &lt; result.length; j++) &#123; if (arr[i] === result[j]) &#123; isRepeat = true break &#125; &#125; if (!isRepeat) &#123; result.push(arr[i]) &#125; &#125; return result&#125;unique([1,1,2,3,4]) 利用indexOf()， 但是indexOf会一直循环到找到目标为止，浪费了时间 12345678910111213function unique (arr) &#123; var result = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (result.indexOf(arr[i]) === -1) &#123; result.push(arr[i]) &#125; &#125; return result&#125;unique([1,1,2,3,4]) 最快的方法 把已经出现过的元素通过下标的形式存入一个Object内。下标的引用的实现原理利用的是哈希算法，要比用indexOf()搜索数组快的多。由于多了一个hash表，占用的内存会更多，空间换时间做法 1234567891011121314function unique (arr) &#123; // hashObj为hash表，result为临时数组 var hashObj = &#123;&#125;, result = [] for (var i = 0; i &lt; arr.length; i++) &#123; // 如果hash表中没有当前项 if (!hashObj[arr[i]]) &#123; // 存入hash表 hashObj[arr[i]] = true // 把当前数组的当前项push到临时数组里面 result.push(arr[i]) &#125; &#125; return result&#125; 折衷方法 时间上比indexOf快，比hash表的方式要慢。先按照从小到大的顺序排序，然后比较相邻的两个值大小 12345678910function unique (arr) &#123; arr.sort() var result = [arr[0]] for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== result[result.length - 1]) &#123; result.push(arr[i]) &#125; &#125; return result&#125; es6的filter()方法 1234567891011121314function unique (arr) &#123; return arr.filter( (value, index) =&gt; &#123; arr.indexOf(value) === index console.log(arr.indexOf(value), index) // 0 0 // 0 1 // 2 2 // 3 3 // 4 4 // 5 5 // 2 6 &#125;)&#125;unique([1,1,2,3,4,5,2]) 12. jquery 里面的 $(document).ready(function(){}) 和 window.onload 的区别 window.onload需要等到页面中包括图片在内的元素全部加载完毕才能执行；ready()是DOM元素绘制结束之后就执行，不用等到加载完毕。 window.onload如果定义了多次，则只会执行一个，后者会覆盖前者； ready()可以同时编写多个，并且都会执行。 window.onload没有简化写法；$(document).ready(function(){})可以简化成$(function(){})。 补充：$(window).load(function(){})和 window.onload()效果一致。 13. 渐进增强与优雅降级 渐进增强 一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再对高级浏览器进行效果、交互的优化，达到更好的体验。 优雅降级 一开始就构建站点的完整功能，然后针对浏览器进行测试和修复。比如一开始使用CSS3的特性构建了一个应用，然后逐步针对各大低级浏览器进行hack使其可以在低版本浏览器上正常浏览。 14. cookies、localStorage和sessionStorage的区别 cookies存在于客户端，始终会在http请求中通过 Request Headers Cookie头携带，即使当前请求不需要使用到cookie；大小一般在4KB，所以只适合保存很小的数据，比如会话标识；cookies在没有设置过期时间（expires）的时候，默认在关闭浏览器之后就会被清除，在有设置过期时间的时候，会一直持续到过期时间有效（即使关闭当前窗口或者关闭浏览器）。 localStorage 和 sessionStorage不会发送数据到服务端，仅在本地保存；也有大小的限制，但一般在5M左右；localStorage一直有效，除非手动清除； sessionStorage只在浏览器关闭之前有效。 另外： localStorage 和 cookies 在同源的浏览器窗口之间是共享的，sessionStorage不共享，因此至少有以下两种方法实现不同页面间的通信： 利用localStorage 123456789// A页面$('#btn').click(function()&#123; localStorage.setItem('name', 'Jnathan')&#125;)// B页面window.addEventListener('storage', function(event)&#123; console.log(event.key + '=' + event.newValue)&#125;) 利用cookie + setInterval() 123456789101112// A页面$('#btn').click(function () &#123; document.cookie = \"name=\" + 'Jnathan'&#125;)// B页面function getKey(key) &#123; return JSON.parse(\"&#123;\\\"\"+ document.cookie.replace(/;\\s+/gim,\"\\\",\\\"\").replace(/=/gim, \"\\\":\\\"\") +\"\\\"&#125;\")[key]; &#125;setInterval(function()&#123; console.log('name:', getKey('name'))&#125;, 1000) 15. new 操作符的四个步骤12var Fn = function() &#123;&#125;var fn = new Fn() 创建一个空对象 1var obj = new Object() 设置obj的原型，将obj的原型指向Fn的原型链 1obj.__proto__ = Fn.prototype 将Fn中的this指向obj,并执行Fn 1var result = Fn.call(obj) 判断Fn的返回值类型。如果是引用类型，则返回这个引用类型的对象；如果是值类型，则返回obj` 12345if (typeof result == 'object') &#123; // 引用类型 fn = result&#125; else &#123; // 值类型 fn = obj&#125; 16. 构造函数实现继承的几种方式1234567function Animal () &#123; this.species = '动物'&#125;function Cat (name, color) &#123; this.name = name this.color = color&#125; 使猫继承动物： call apply 12345678function Cat (name, color) &#123; Animal.apply(this, arguments) this.name = name this.color = color&#125;var cat1 = new Cat('name1', 'color1')alert(cat1.species) // 动物 prototype（其一） 12345678function Cat (name, color) &#123; Animal.apply(this, arguments) this.name = name this.color = color&#125;var cat1 = new Cat('name1', 'color1')alert(cat1.species) // 动物 prototype（其二） 12345678function Animal () &#123;&#125;Animal.prototype.species = '动物'Cat.prototype = Animal.prototypeCat.prototype.constructor = Catvar cat3 = new Cat('name3', 'color3')alert(cat3.species) // 动物 利用空对象作为中介 上面那种方法的缺点：Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。 1234var Fn = function () &#123;&#125;Fn.prototype = Animal.prototypeCat.prototype = new Fn()Cat.prototype.construvtor = Cat 将其封装成一个函数 12345678910function extend (Child, Parent) &#123; var Fn = function () &#123;&#125; Fn.prototype = Parent.prototype Child.prototype = new Fn() Child.prototype.constructor = Child&#125;extend(Cat, Animal)var cat4 = new Cat('name4', 'color4')alert(cat4.species) // 动物 拷贝继承 123456789101112131415function Animal () &#123;&#125;Animal.species = '动物'function extend2 () &#123; var C = Child.prototype var P = Parent.prototype for (var i in P) &#123; C[i] = P[i] &#125;&#125;extend2(Cat, Animal)var cat5 = new Cat('name5', 'color5')alert(cat5.species) // 动物 17. 非构造函数的继承123456var Chinese = &#123; nation: '中国'&#125;var Doctor = &#123; career: '医生'&#125; 浅拷贝 123456789101112function shallowCopy (Parent) &#123; var Child = &#123;&#125; for (var i in Parent) &#123; Child[i] = Parent[i] &#125; return Child&#125;var doctor1 = shallowCopy(Chinese)alert(doctor1.nation) // 中国 深拷贝 1234567891011121314151617function deepCopy (Child, Parent) &#123; var Child = Child || &#123;&#125; for (var i in Parent) &#123; if (typeof Parent[i] == 'object') &#123; Child[i] = (Parent[i].constructor === Array) ? [] : &#123;&#125; deepCopy(Child[i], Parent[i]) &#125; else &#123; Child[i] = Parent[i] &#125; &#125; return Child&#125;var doctor2 = deepCopy(Doctor, Chinese)alert(doctor.nation) // 中国 18. 参考链接","comments":true,"tags":[{"name":"dairy","slug":"dairy","permalink":"https://JnathanCoder.github.io/tags/dairy/"}]},{"title":"forEach遍历中断","date":"2019-05-22T09:28:36.000Z","path":"2019/05/22/forEach-interrupt/","text":"123456789101112131415try &#123; [22, 34, 20, 36, 98].forEach( (value, index, arr) =&gt; &#123; if (value === 20) &#123; console.log('遇到20能够退出循环吗？') throw Error('自定义异常提示语') return // return并不能中断循环，这里可写可不写 &#125; else console.log('当前遍历值：', value) &#125;)&#125; catch(err) &#123; console.log(err.message)&#125;// 22// 34// 遇到20能够退出循环吗？// 自定义异常提示语","comments":true,"tags":[]},{"title":"使用 void 0 代替 undefined","date":"2019-05-22T09:02:31.000Z","path":"2019/05/22/void-0/","text":"What…1void 0 === undefined // true Why？ 防止undefined被重写 在ES5之前，window下的undefined是可以被重写的，于是导致了某些极端情况下使用undefined会出现一定的差错。 所以，用void 0是为了防止undefined被重写而出现判断不准确的情况。 事实上，void的返回值都是undefined。ES5之后的标准中，规定了全局变量下的undefined值为只读，不可改写的，但是局部变量中依然可以对之进行改写。补充一下：非严格模式下，undefined是可以重写的，严格模式则不能重写。 节省字节 void 0代替undefined节省3个字节，类似的还有以下用法： 1234567891011121314151617181920212223242526272829303132// 取整操作parseInt(a,10) // BeforeMath.floor(a) // Beforea&gt;&gt;0 // Before~~a // Aftera|0 // After// 四舍五入操作Math.round(a) // Beforea+.5|0 // After// 内置值undefined // Beforevoid 0 // After, 快0[0] // After, 略慢// 内置值Infinity1/0// 布尔值短写法true; // Beforefalse // Before!1 // After!0; // After// 获取上下文对象var global = (function () &#123; return this || (0, eval)('this')&#125;())// (0, eval)('this') 等价于 eval('this') 正常情况下可以直接使用 eval()// 部分低版本IE下，不可以直接运行eval()。","comments":true,"tags":[]},{"title":"this + bind + call + apply","date":"2019-05-21T07:05:59.000Z","path":"2019/05/21/this/","text":"this的指向 this的指向总结起来就是this永远指向最后调用它的那个对象 例1： 123456789var name = 'global'function test() &#123; var name = 'cherry' console.log(this) console.log(this.name)&#125;test()// window// global 调用 test 方法的地方是 test() ，前面没有调用的对象即为 window （严格模式下为 undefined ），相当于 window.test() 。 例2： 123456789var name = 'global'var obj = &#123; name: 'cherry', fn: function () &#123; console.log(this.name) &#125;&#125;obj.fn() // cherrywindow.obj.fn() // cherry obj.fn() 取用的是 obj 对象 里面的 name 值， window.obj.fn() 里面，最后调用的是 obj 对象，所以也是 cherry 。补充：假如将 obj 对象中 name 属性的定义注释掉，那么 obj.fn() 将会打印出 undefined ，因为只会看最近的调用 obj 对象 ，当没有定义时，不会继续向上一个对象 window 寻找 name 属性。 例3： 123456789var name = 'global'var obj = &#123; name: 'cherry', fn: function () &#123; console.log(this.name) &#125;&#125;var temp = obj.fn()temp() // global 再来看一遍：this 永远指向 最后调用 它的那个对象。 obj.fn() 赋值给 temp 时，并没有进行赋值！最后 temp() 调用的时候是 window.temp() ，所以打印 global 。 例4： 123456789var name = 'global'function fn () &#123; var name = 'cherry' innerFn() function innerFn () &#123; console.log(this.name) &#125;&#125;fn() // global 例5： 1234567891011121314151617181920function Func () &#123; this.name = 'cherry'&#125;var fn = new Func()console.log(fn.name) // cherry// =================================function Func2 () &#123; this.name = 'cherry' return &#123;name: 'apple'&#125; // 返回一个对象 如果name改为name2，fn2.name为undefined&#125;function Func3 () &#123; this.name = 'cherry' return true // 返回true，非对象（false, 124, 'abc'都可）&#125;var fn2 = new Func2()console.log(fn2.name) // applevar fn3 = new Func3()console.log(fn3.name) // cherry 当我们通过 new 关键字构造一个实例对象的过程中，构造函数中的 this 一般情况下指向我们构造出来的实例化对象，因此在构造过程中 this.name = &#39;cherry&#39; 这句代码就相当于给实例对象 fn 创建了一个 name 属性并赋值 cherry 。特别的，当构造函数中的 this 遇到 return 的情况。当构造函数中返回值是一个对象时，this 指向的就是返回的那个对象；如果返回值不是对象时，this 指向的就是构造函数（这里是 Func3 ）。 改变this的指向例6： 12345678910111213var name = 'global'var obj = &#123; name: 'cherry', fn1: function () &#123; console.log(this.name) &#125;, fn2: function () &#123; setTimeout(function () &#123; this.fn1() &#125;, 1000) &#125;&#125;obj.fn2() // this.fn1 is not a function setTimeout() 即为 window.setTimeout() ，最后调用的对象是 window，而 window 中并没有方法 fn1() ，故而报错。 我们通常使用以下几种方法改变this的指向问题： var _this = this 12345678// ...fn2: function () &#123; var _this = this setTimeout(function () &#123; _this.fn1() // cherry &#125;, 1000)&#125;// ... 箭头函数 1234567// ...fn2: function () &#123; setTimeout( () =&gt; &#123; this.fn1() // cherry &#125;, 1000)&#125;// ... bind 1234567// ...fn2: function () &#123; setTimeout(function () &#123; this.fn1() // cherry &#125;. bind(obj)(), 1000) // 这里的obj也可以换成this this指向obj&#125;// ... call 1234567// ...fn2: function () &#123; setTimeout(function () &#123; this.fn1() // cherry &#125;.call(obj), 1000) // 这里的obj也可以换成this this指向obj&#125;// ... apply 1234567// ...fn2: function () &#123; setTimeout(function () &#123; this.fn1() // cherry &#125;.apply(obj), 1000) // 这里的obj也可以换成this this指向obj&#125;// ... bind介绍 bind() 方法创建一个 新的函数， 当被调用时，将其 this 关键字设置为提供的值。在调用新函数时，在任何提供之前提供一个给定的参数序列。 例7： 123456789var obj = &#123; func: function (a, b) &#123; console.log('乘积： ' + a * b) &#125;&#125;obj.func.bind(obj, 2, 8) // f (a, b) &#123; // console.log('乘积： ' + a * b) // &#125;obj.func.bind(obj, 2, 8)() // 乘积： 16 因为 bind 只会重新赋予 this，并不会自动执行，需要手动执行，固有第二个的结果。 call介绍 functionObj.call(thisArg[, args1, args2, args3, …]) thisArg -&gt; 函数在运行时指定的 this 。当为 null 或者 undefined 时，自动指向 window 。当为string 、number 、boolean 类型的时候，this 指向各自的包装对象。 123456789101112function test () &#123; console.log('this: ' + this)&#125;test.call(null) // windowtest.call(undefined) // windowtest.call('abcd') // Stringtest.call(128) // Numbertest.call(false) // Boolean// apply() 的结果与 call() 一致test.apply(null) // window// ... 例8： 1234567var obj = &#123; name: 'hello', func: function (a, b) &#123; console.log('乘积： ' + a * b) &#125;&#125;obj.func.call(obj, 2, 5) // 乘积： 10 apply介绍 functionObj.apply(thisArg[, argsArr]) apply 的语法和 call 的语法类似，区别在于 apply 的参数列表是以 数组 或者 类数组 形式传入。 例9： 1234567var obj = &#123; name: 'hello', func: function (a, b) &#123; console.log('乘积： ' + a * b) &#125;&#125;obj.func.apply(obj, [2, 6]) // 乘积： 12 call、apply常见用法 将类数组 ArrayLike 转换成数组 Array 12345678910111213141516var arraylike = &#123;'1': 'hello', '2': 'world', '3': 'balabala', length: 4&#125;function ArrTransfer () &#123; // return [].slice.call(arguments) return Array.prototype.slice.call(arguments) // return [].splice.call(arguments, 0) // return Array.prototype.splice.call(arguments, 0) // return Array.from(arguments)&#125;var list = ArrTransfer(arrayLike) // [&#123;'1': 'hello', '2': 'world', '3': 'balabala', length: 3&#125;]Array.prototype.slice.call(arrayLike).forEach( (elem, index) =&gt; &#123; console.log(elem, index) // hello 1 // world 2 // balabala 3&#125;) 求最大最小值 123var arr = [21, 2, 35, 9, 23, 16, 29]Math.max.apply(Math, arr) // 35Math.min.apply(Math, arr) // 2 Useful Link 全文参考自掘金文章","comments":true,"tags":[{"name":"this","slug":"this","permalink":"https://JnathanCoder.github.io/tags/this/"},{"name":"作用域","slug":"作用域","permalink":"https://JnathanCoder.github.io/tags/作用域/"}]},{"title":"企业微信中超链接地址跳转","date":"2019-05-21T03:04:11.000Z","path":"2019/05/21/wxwork-link-unRirect/","text":"问题描述：在ios(版本号未测试)企业微信(版本号未测试)中，并且超链接target属性是_blank时，点击超链接不能正常跳转，当前页面自动刷新一次。而在ios微信浏览器以及android中未复现。 解决办法 直接修改target属性值为非_blank即可； 如果是从富文本编辑器中出来的html内容，可以借助js进行处理。示意代码如下： 1234let oAList = document.querySelectorAll('a')Array.from(oAList).forEach( (aLink, index) =&gt; &#123; aLink.getAttribute('target') === '_blank' ? aLink.setAttribute('target', '_self') : null // 设置成null也可&#125;)","comments":true,"tags":[{"name":"企微","slug":"企微","permalink":"https://JnathanCoder.github.io/tags/企微/"},{"name":"超链接","slug":"超链接","permalink":"https://JnathanCoder.github.io/tags/超链接/"}]},{"title":"CSS文本超出容器宽度使用省略号代替（不考虑js方法）","date":"2019-03-31T16:00:00.000Z","path":"2019/04/01/text-overflow-ellipsis/","text":"方法一 ：常规方法（适用于webkit内核浏览器）12&lt;div class=\"container text-ellipsis\"&gt;单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号&lt;/div&gt;&lt;div class=\"container text-ellipsis-multi\"&gt;多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号&lt;/div&gt; 1234567891011121314151617181920.container &#123; display: inline-block; width: 333px; height: 60px; font-size: 16px; border: 1px solid #00bebe;&#125;.text-ellipsis &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;.text-ellipsis-multi &#123; line-height: 20px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; // 控制显示的行数 -webkit-box-orient: vertical;&#125; 在webkit浏览器中的表现： 方法二：利用伪类+float（适用于大部分浏览器）原理讲解参考这里 123&lt;div class=\"wrap\"&gt; &lt;div class=\"text\"&gt;多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930.wrap &#123; background: #099; max-height: 40px; line-height: 20px; overflow: hidden;&#125;.wrap:before &#123; float: left; content: ''; width: 20px; height: 40px;&#125;.wrap .text &#123; float: right; width: 100%; margin-left: -20px; word-break: break-all;&#125;.wrap:after &#123; float: right; content: '...'; width: 20px; height: 20px; &lt;!-- 下方三行代码 调整省略号位置 --&gt; &lt;!-- 未超出时，省略号在wrap外面，被隐藏 --&gt; position: relative; left: 100%; transform: translate(-100%, -100%);&#125; 在非webkit内核浏览器中的表现： 可以看到效果还是不那么尽人意，可以在此基础上再根据实际情况修改相应代码，比如...用渐变色代替现在的白色，会显得平滑。另外，也可以搭配js进一步处理，可以参考这里。 也可使用封装好的 vue组件 。 更详细的文章参考这里。","comments":true,"tags":[{"name":"ellipsis","slug":"ellipsis","permalink":"https://JnathanCoder.github.io/tags/ellipsis/"},{"name":"换行","slug":"换行","permalink":"https://JnathanCoder.github.io/tags/换行/"},{"name":"省略号","slug":"省略号","permalink":"https://JnathanCoder.github.io/tags/省略号/"}]}]