[{"title":"css-border-animation","date":"2021-01-19T02:11:11.000Z","path":"2021/01/19/css-border-animation/","text":"Hover Me 1&lt;div class=\"css-border1\"&gt;Hover Me&lt;/div&gt; 123456789101112131415161718192021.css-border1 &#123; width: 100px; height: 100px; line-height: 100px; text-align: center; cursor: pointer; background: linear-gradient(to right, currentColor 50%, transparent 50%) repeat-x, linear-gradient(to right, currentColor 50%, transparent 50%) repeat-x, linear-gradient(to bottom, currentColor 50%, transparent 50%) repeat-y, linear-gradient(to bottom, currentColor 50%, transparent 50%) repeat-y; background-size: 5px 1px, 5px 1px, 1px 5px, 1px 5px; background-position: 0 0, 0 100%, 0 0, 100% 0;&#125;.css-border1:hover &#123; animation: animation1 .1s linear infinite;&#125;@keyframes animation1 &#123; 100% &#123; background-position: 5px 0, -5px 100%, 0 -5px, 100% 5px; &#125;&#125; 利用渐变+伪元素画出来四块背景图形 1&lt;div class=\"border-wrapper2\"&gt;&lt;div class=\"css-border2\"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627.border-wrapper2 &#123; width: 100px; height: 100px; overflow: hidden; position: relative; border-radius: 10px;&#125;.css-border2 &#123; width: 100px; height: 100px; position: relative;&#125;.css-border2:after &#123; content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background-image: linear-gradient(#399953, #399953), linear-gradient(#fbb300, #fbb300), linear-gradient(#d53e33, #d53e33), linear-gradient(#377af5, #377af5); background-size: 50% 50%; background-position: 0 0, 100% 0, 100% 100%, 0 100%; background-repeat: no-repeat;&#125; 在上图基础上，加上遮罩盖掉多余的部分，并加上旋转 codepen示例 1&lt;div class=\"border-wrapper3\"&gt;&lt;div class=\"css-border3\"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142.border-wrapper3 &#123; width: 100px; height: 100px; overflow: hidden; position: relative; border-radius: 10px;&#125;.border-wrapper3:before &#123; content: ''; position: absolute; z-index: 10; top: 2px; bottom: 2px; left: 2px; right: 2px; background: #fff; border-radius: 10px;&#125;.css-border3 &#123; width: 100px; height: 100px; animation: animation2 2s linear infinite; position: relative;&#125;.css-border3:after &#123; content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background-image: linear-gradient(#399953, #399953), linear-gradient(#fbb300, #fbb300), linear-gradient(#d53e33, #d53e33), linear-gradient(#377af5, #377af5); background-size: 50% 50%; background-position: 0 0, 100% 0, 100% 100%, 0 100%; background-repeat: no-repeat;&#125;@keyframes animation2 &#123; 100% &#123; transform: rotate(1turn); &#125;&#125; conic-gradient 角向(圆锥)渐变 (edge≥79支持) codepen示例 conic-gradient 饼图 (怎么感觉有种opacity的效果😶) 重复圆锥渐变绘制抽奖圆盘 codepen示例 圆锥渐变绘制信封效果 codepen示例","comments":true,"tags":[{"name":"css","slug":"css","permalink":"https://JnathanCoder.github.io/tags/css/"},{"name":"border","slug":"border","permalink":"https://JnathanCoder.github.io/tags/border/"}]},{"title":"css 常见图形","date":"2020-12-26T13:49:45.000Z","path":"2020/12/26/css-custom-shape/","text":"1. 三角形1.1 上三角 1&lt;div class=\"up-triangle\"&gt;&lt;/div&gt; 1234567.up-triangle &#123; display: inline-block; width: 0; height: 0; border-left: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid #00bebe;&#125; 1.2 下三角 1234567.down-triangle &#123; display: inline-block; width: 0; height: 0; border-left: 20px solid transparent; border-right: 20px solid transparent; border-top: 20px solid #00bebe;&#125; 1&lt;div class=\"down-triangle\"&gt;&lt;/div&gt; 1.3 左三角 1234567.left-triangle &#123; display: inline-block; width: 0; height: 0; border-top: 20px solid transparent; border-bottom: 20px solid transparent; border-right: 20px solid #00bebe;&#125; 1&lt;div class=\"left-triangle\"&gt;&lt;/div&gt; 1.4 右三角 1234567.right-triangle &#123; display: inline-block; width: 0; height: 0; border-top: 20px solid transparent; border-bottom: 20px solid transparent; border-left: 20px solid #00bebe;&#125; 1&lt;div class=\"right-triangle\"&gt;&lt;/div&gt; 1.5 带线框的三角形1.5.1 两个三角形叠加 谷歌翻译使用的方法这是对话内容 1234567891011121314151617181920212223242526272829.custom-speaking1 &#123; display: inline-block; padding: 10px; border: 1px solid #00bebe; filter: drop-shadow(); position: relative;&#125;.custom-triangle1 &#123; position: absolute; top: -11px; left: 30px;&#125;.custom-triangle1:before &#123; content: ''; position: absolute; left: -11px; border-left: 11px solid transparent; border-right: 11px solid transparent; border-bottom: 11px solid #00bebe;&#125;.custom-triangle1:after &#123; content: ''; position: absolute; left: -10px; top: 1px; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 10px solid #fff;&#125; 1234&lt;div class=\"custom-speaking1\"&gt; &lt;div&gt;这是对话内容&lt;/div&gt; &lt;div class=\"custom-triangle1\"&gt;&lt;/div&gt;&lt;/div&gt; 1.5.2 多重渐变背景正方形+旋转 来源Demo这是对话内容 123456789101112131415.custom-speaking2 &#123; display: inline-block; padding: 10px; border: 1px solid #00bebe; position: relative;&#125;.custom-speaking2:before&#123; content: ''; position: absolute; top: 16px; left: -6px; width: 10px; height: 10px; background: linear-gradient(to top, blue, blue) no-repeat, linear-gradient(to right, green, green) no-repeat, linear-gradient(to right bottom, #fff, #fff 10px, rgba(0, 0, 0, 0) 10px) no-repeat; background-size: 10px 1px, 1px 10px, 10px 10px; transform: rotate(-45deg);&#125; 1&lt;div class=\"custom-speaking2\"&gt;这是对话内容&lt;/div&gt; transparent 10px → rgba(0, 0, 0, 0) 10px，新升级Firefox下transparent边缘会有灰色背景渲染bug，使用rgba或hsla白色透明表示可修复。 2. 比例可控制的虚线 1:1 3:71234567891011121314.dashed-line1 &#123; display: inline-block; width: 200px; height: 1px; background: linear-gradient(to right, black, black 5px, transparent 5px, transparent); background-size: 10px 1px;&#125;.dashed-line2 &#123; display: inline-block; width: 200px; height: 1px; background: linear-gradient(to right, black, black 3px, transparent 3px, transparent); background-size: 10px 1px;&#125;12&lt;div class=\"dashed-line1\"&gt;&lt;/div&gt;&lt;div class=\"dashed-line2\"&gt;&lt;/div&gt;### 3. 加号减号&emsp; 12345678910111213141516171819202122.custom-minus &#123; display: inline-block; width: 30px; height: 30px; border-radius: 3px; background: linear-gradient(to right, currentColor, currentColor); background-color: #f0f1f2; background-position: center; background-size: 15px 2px; background-repeat: no-repeat;&#125;.custom-plus &#123; display: inline-block; width: 30px; height: 30px; border-radius: 3px; background: linear-gradient(to right, currentColor, currentColor); background-color: #f0f1f2; background-position: center; background-size: 15px 2px; background-repeat: no-repeat;&#125; 12&lt;div class=\"custom-minus\"&gt;&lt;/div&gt;&lt;div class=\"custom-plus\"&gt;&lt;/div&gt;","comments":true,"tags":[{"name":"css","slug":"css","permalink":"https://JnathanCoder.github.io/tags/css/"}]},{"title":"前端优化之Pre相关术语","date":"2020-09-09T06:00:56.000Z","path":"2020/09/09/preload-prefetch-async-defer/","text":"DNS prefetch用于告知浏览器预先获取指定的域名的DNS，以便在使用时可以减少DNS查找。 1&lt;link rel=\"dns-prefetch\" href=\"//the-domain-to-be-prefetched.com\" /&gt; preconnect 预连接预连接。和DNS Prefetch类似，但是，更进一步。它不仅要求浏览器预解析指定域名的DNS，还需要预先与服务器握手以及TLS协商（如果使用了HTTPS）。 1&lt;link rel=\"preconnect\" href=\"//the-domain-to-be-preconnect.com\" crossorigin=\"anonymous\" /&gt; preload 预加载 link 元素的 rel 属性的属性值 preload 能够让你在你的HTML页面中 head 元素内部书写一些声明式的资源获取请求，可以指明哪些资源是在页面加载完成后即刻需要的。对于这种即刻需要的资源，你可能希望在页面加载的生命周期的早期阶段就开始获取，在浏览器的主渲染机制介入前就进行预加载。这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。 preload 的资源会被优先加载，但不会阻塞doument的渲染以及页面的onload事件。一般用于对页面很重要的资源上，比如 字体文件。如果预加载进来的资源在3s内没有使用，浏览器会在控制台打印警告信息。 preload有许多好处： 更精确地优化资源加载优先级。 匹配未来的加载需求，在适当的情况下，重复利用同一资源。 为资源应用正确的内容安全策略。 为资源设置正确的 Accept 请求头。 预 prefetch 的区别 Prefetch的优先级很低，低到浏览器可以不加载 Preload的优先级很高，浏览器一定要加载 Preload加载的资源用于当前页面中 Prefetch加载的资源用于将来某个页面中（这意味着它可能压根不会被用到） 指定资源类型 as指定被预加载资源的类型。as属性值为css/script时，优先级很高。 跨域获取 crossOrigin如需加载跨域的资源列表，则需要正确设置CORS，接着便可以在 link 元素中设置好crossorigin属性即可。(由于历史原因，加载字体时，无论有没有跨域，都需要添加crossOrigin) 1&lt;link rel=\"preload\" as=\"font\" type=\"font/woff2\" href=\"path/to/font\" crossOrigin&gt; 包含媒体 medialink 元素有一个很棒的特性是它们能够接受一个media属性。它们可以接受媒体类型或有效的媒体查询作为属性值，这将令你能够使用响应式的预加载！ 12&lt;link rel=\"preload\" href=\"bg-image-narrow.png\" as=\"image\" media=\"(max-width: 600px)\"&gt;&lt;link rel=\"preload\" href=\"bg-image-wide.png\" as=\"image\" media=\"(min-width: 601px)\"&gt; 12345678var mediaQueryList = window.matchMedia(\"(max-width: 600px)\");var header = document.querySelector('header');if(mediaQueryList.matches) &#123; header.style.backgroundImage = 'url(bg-image-narrow.png)';&#125; else &#123; header.style.backgroundImage = 'url(bg-image-wide.png)';&#125; 脚本化预加载预加载 12345var preloadLink = document.createElement(\"link\");preloadLink.href = \"myscript.js\";preloadLink.rel = \"preload\";preloadLink.as = \"script\";document.head.appendChild(preloadLink); 执行 123var preloadedScript = document.createElement(\"script\");preloadedScript.src = \"myscript.js\";document.body.appendChild(preloadedScript); prefetch 预获取关键字 prefetch 作为元素 link 的属性 rel 的值，是为了提示浏览器，用户未来的浏览有可能需要加载目标资源，所以浏览器有可能通过事先获取和缓存对应资源，优化用户体验。 prerender 预渲染 与Prefetch类似，浏览器会下载整个资源，但是，Prefetch不允许浏览器对资源做预处理和执行，而Prerender则会告知浏览器，下载资源（HTML）并解析/执行它，包括被解析资源的子资源，这意味着会下载该HTML中的图片、样式、脚本等等。Prerender没有as属性，它下载的是HTML 1&lt;link rel=\"prerender\" href=\"//the-domain-to-be-preconnect.com\" /&gt; subresource指定预加载资源拥有加载的最高优先级 script defer1&lt;script src=\"path/to/script.js\" defer&gt;&lt;/script&gt; 加载后续文档元素的过程与 script.js 的加载并行进行（异步），但是 script.js 的执行要等到所有文档元素加载和解析之后，在 DOMContentLoaded 之前执行。 script async1&lt;script src=\"path/to/script.js\" async&gt;&lt;/script&gt; 加载后续文档元素的过程与 script.js 的加载以及执行都并行进行（异步）。 script1&lt;script src=\"path/to/script.js\"&gt;&lt;/script&gt; 浏览器会立即加载并执行 script.js. 立即 指的是在渲染script标签之后（下）的文档元素之前，不等待标签之后的文档元素载入，读到了就开始加载并执行。 附三种情形下的图示（ 图片来源） ES Module详情参考 资料 MDN 前端模块化的今生","comments":true,"tags":[{"name":"前端优化","slug":"前端优化","permalink":"https://JnathanCoder.github.io/tags/前端优化/"}]},{"title":"defineproperty-proxy","date":"2020-08-31T08:25:17.000Z","path":"2020/08/31/defineproperty-proxy/","text":"在一篇 掘金文章 中看到这样一道题目，大概是以下的需求。 补全Observe函数，使得执行 proxyObj.name = &#39;大大&#39; 时，打印 属性[name]的值被修改为[大大]。 1234567891011function Observe(obj, callback) &#123; // TO DO&#125;let oldObj = &#123; name: '小小', uid: 108&#125;const proxyObj = Observe(oldObj, (key, value) =&gt; &#123; console.log(`属性[$&#123;key&#125;]的值被修改为[$&#123;value&#125;]`)&#125;) 1. Object.defineProperty1234567891011121314151617181920212223242526272829303132333435363738function Observe(obj, callback) &#123; const observedObj = &#123;&#125; Object.keys(obj).forEach( (key) =&gt; &#123; Object.defineProperty(observedObj, key, &#123; configurable: true, enumerable: true, get: () =&gt; &#123; console.log('emit getter', key) return obj[key] &#125;, set: (newVal) =&gt; &#123; console.log('emit setter', key) obj[key] = newVal callback(key, newVal) &#125; &#125;) &#125;) return observedObj&#125;let oldObj = &#123; name: '小小', uid: 108&#125;const proxyObj = Observe(oldObj, (key, value) =&gt; &#123; console.log(`属性[$&#123;key&#125;]的值被修改为[$&#123;value&#125;]`)&#125;)// output:// emit getter name// 小小console.log(proxyObj.name)// output:// emit setter name// 属性[name]的值被修改为[大大]proxyObj.name = '大大' 2. Proxy12345678910111213141516171819202122232425262728293031function Observe(obj, callback) &#123; return new Proxy(obj, &#123; get: (target, key) =&gt; &#123; console.log('emit getter', key) return target[key] &#125;, set: (target, key, newVal) =&gt; &#123; console.log('emit setter', key) obj[key] = newVal callback(key, newVal) &#125; &#125;)&#125;let oldObj = &#123; name: '小小', uid: 108&#125;const proxyObj = Observe(oldObj, (key, value) =&gt; &#123; console.log(`属性[$&#123;key&#125;]的值被修改为[$&#123;value&#125;]`)&#125;)// output:// emit getter name// 小小console.log(proxyObj.name)// output:// emit setter name// 属性[name]的值被修改为[大大]proxyObj.name = '大大' 3. 对比 在Vue2.0中，数据双向绑定就是通过Object.defineProperty去监听对象的每一个属性，然后在get,set方法中通过发布订阅者模式来实现的数据响应，但是存在一定的缺陷，比如只能监听已存在的属性，对于新增删除属性就无能为力了，同时无法监听数组的变化，所以在Vue3.0中将其换成了功能更强大的Proxy。 在上面的代码中，如果执行 proxyObj.newVariable = &#39;haha&#39;，defineProperty实现将不能触发setter方法，Proxy实现能够触发。 4. 了解Proxy Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等） 4.0 基本语法1const proxy = new Proxy(target, handler) 在上面的代码中，已经使用到了handler里的get与set。除此之外还有11个方法，共计13个。重点描述几个常用的方法。 4.1 handler.get(target, key, receiver) 属性读取操作的捕捉器。当通过proxy去读取对象里面的属性的时候，会进入到get钩子函数里面。 target 目标对象 key 被获取的属性名 receiver Proxy或者集成Proxy的对象 123456const proxy = new Proxy(&#123;&#125;, &#123; get(target, key, receiver) &#123; console.log('emit getter', target, key, receiver) return target[key] &#125;&#125;) 如果违背了以下的约束，proxy会抛出 TypeError 如果要访问的目标属性是 不可写 并且 不可配置 的，则返回的值必须与该目标属性的值相同。 如果要访问的目标属性没有配置访问方法，即get方法是undefined的，则返回值必须为undefined。(没理解，未配置get方法，返回值怎么定义?) 12345678910111213var obj = &#123;&#125;Object.defineProperty(obj, 'age', &#123; configurable: false, writable: false, value: 10&#125;)var p = new Proxy(obj, &#123; get(target, key) &#123; return 20 &#125;&#125;)// Uncaught TypeError: 'get' on proxy: property 'age' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected '10' but got '20')console.log(p.age) 4.2 handler.set(target, key, value, receiver) 属性设置操作的捕捉器。当通过proxy去为对象设置修改属性的时候，会进入到set钩子函数里面。 target 目标对象 key 将被设置的属性名或 Symbol value 新属性值 receiver 最初被调用的对象。通常是 proxy 本身，但 handler 的 set 方法也有可能在原型链上，或以其他方式被间接地调用（因此不一定是 proxy 本身）。比如：假设有一段代码执行 obj.name = “jen”， obj 不是一个 proxy，且自身不含 name 属性，但是它的原型链上有一个 proxy，那么，那个 proxy 的 set() 处理器会被调用，而此时，obj 会作为 receiver 参数传进来。 返回值 set() 方法应当返回一个布尔值 返回 true 代表属性设置成功。 在严格模式下，如果 set() 方法返回 false，那么会抛出一个 TypeError 异常。 如果违背了以下的约束，proxy会抛出 TypeError 若目标属性是一个不可写以及不可配置的数据属性，则不能改变它的值。(但是经过测试，并没有抛出错误❌) 如果目标属性没有配置存储方法，即 [[Set]] 属性的是 undefined，则不能设置它的值。(同样的疑问，没有set方法，如何设置值呢?) 在严格模式下，如果 set() 方法返回 false，那么也会抛出一个 TypeError 异常。 12345678var p = new Proxy(&#123;&#125;, &#123; set(target, key, value, receiver) &#123; target[key] = value // 非严格模式下可省略 return true &#125;&#125;)p.age = 10 12345678910\"use strict\"var p = new Proxy(&#123;&#125;, &#123; set(target, key, value, receiver) &#123; target[key] = value // 严格模式没有返回值或返回false 会抛出TypeError return false &#125;&#125;)// Uncaught TypeError: 'set' on proxy: trap returned falsish for property 'age'p.age = 10 1234567891011121314var obj = &#123;&#125;Object.defineProperty(obj, 'age', &#123; configurable: false, writable: false, value: 10&#125;)var p = new Proxy(obj, &#123; set(target, key, value, receiver) &#123; target[key] = value return true &#125;&#125;)// 设置成功 没有抛错误❌p.age = 20 对比Vue2.x 在使用Vue2.0的时候，如果给对象添加新属性的时候，往往需要调用 $set, 这是因为Object.defineProperty只能监听已存在的属性，而新增的属性无法监听，而通过 $set 相当于手动给对象新增了属性，然后再触发数据响应。但是对于Vue3.0来说，因为使用了Proxy，在他的set钩子函数中是可以监听到新增属性的，所以就不再需要使用 4.3 handler.has(target, key) in 操作符的捕捉器。当使用in判断属性是否在proxy代理对象里面时，会触发。 target 目标对象 key 需要检查是否存在的属性. 返回值 has 方法返回一个 boolean 属性的值. 1234567891011121314const obj = &#123; publicFn() &#123;&#125;, _privateFn() &#123;&#125;&#125;const p = new Proxy(obj, &#123; has(target, key) &#123; if (key.startWith('_')) &#123; return false &#125; return target[key] &#125;&#125;)console.log('publicFn' in obj) // trueconsole.log('_privateFn' in obj) // false 如果违反了下面这些规则, proxy 将会抛出 TypeError: 如果目标对象的某一属性本身不可被配置，则该属性不能够被代理隐藏(怎么写示例…) 如果目标对象为不可扩展对象，则该对象的属性不能够被代理隐藏 123456789var obj = &#123; age: 10 &#125;Object.preventExtensions(obj)var p = new Proxy(obj, &#123; has: function(target, key) &#123; return false &#125;&#125;)// Uncaught TypeError: 'has' on proxy: trap returned falsish for property 'a' but the proxy target is not extensibleconsole.log('age' in p) 4.4 handler.deleteProperty(target, key) delete 操作符的捕捉器。当使用delete去删除对象里面的属性的时候，会进入deleteProperty`钩子函数 target 目标对象 key 待删除的属性名 返回值 deleteProperty 必须返回一个 Boolean 类型的值，表示了该属性是否被成功删除。 12345678910111213141516var p = new Proxy(&#123; name: 'zhangsan', age: 10 &#125;, &#123; deleteProperty(target, key) &#123; console.log(target, key) if (key === 'name') &#123; console.log('属性' + key + '不可以被删除') return false &#125; delete target[key] return true &#125;&#125;)// true undefinedconsole.log(delete p.age, p.age)// 属性name不可以被删除// false zhangsanconsole.log(delete p.name, p.name) 如果违背了以下不变量，proxy 将会抛出一个 TypeError: 如果目标对象的属性是不可配置的，那么该属性不能被删除 12345678910111213var obj = &#123;&#125;Object.defineProperty(obj, 'age', &#123; configurable: false, value: 10&#125;)var p = new Proxy(obj, &#123; deleteProperty(target, key) &#123; delete target[key] return true &#125;&#125;)// Uncaught TypeError: 'deleteProperty' on proxy: trap returned truish for property 'age' which is non-configurable in the proxy targetconsole.log(delete p.age, p.age) 对比vue2.x 其实与 $set 解决的问题类似，Vue2.0是无法监听到属性被删除的，所以提供了 $delete 用于删除属性，但是对于Proxy，是可以监听删除操作的，所以就不需要再使用 $delete 了 4.5 handler.apply(target, thisArg, argumentsList) 函数调用操作的捕捉器。当proxy监听的是一个函数的时候，当调用这个函数时，会进入apply钩子函数 target 目标对象（函数） thisArg 被调用时的上下文对象 argumentsList 被调用时的参数数组 返回值 可返回任何值 1234567var p = new Proxy(function() &#123;&#125;, &#123; apply(target, thisArg, argumentsList) &#123; return argumentsList[0] + argumentsList[1] + argumentsList[2] &#125;&#125;)// 6console.log(p(1, 2, 3)) 如果违反了以下约束，代理将抛出一个TypeError： target必须是可被调用的。也就是说，它必须是一个函数对象。上面的代码中，将 function(){} 改成 {} 将会报错 4.6 handler.ownKeys当通过 Object.getOwnPropertyNames,Object.getownPropertySymbols,Object.keys,Reflect.ownKeys去获取对象的信息的时候，就会进入ownKeys这个钩子函数 4.7 handler.construct当使用new操作符的时候，会进入construct这个钩子函数 4.8 handler.defineProperty当使用Object.defineProperty去修改属性修饰符的时候，会进入这个钩子函数 4.9 handler.getPropertyOf当读取对象的原型的时候，会进入这个钩子函数 4.10 handler.setPropertyOf当设置对象的原型的时候，会进入这个钩子函数 4.11 handler.isExtensible当通过Object.isExtensible去判断对象是否可以添加新的属性的时候，进入这个钩子函数 4.12 handler.preventExtensions当通过Object.preventExtensions去设置对象不可以修改新属性时候，进入这个钩子函数 4.13 handler.getOwnPropertyDescriptor在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, “foo”) 时会进入这个钩子函数 5. Reflect 在上面，我们获取属性的值或者修改属性的值都是通过直接操作target来实现的，但实际上ES6已经为我们提供了在Proxy内部调用对象的默认行为的API,即Reflect。比如下面的代码 123456const obj = &#123;&#125;const proxy = new Proxy(obj, &#123; get(target, key, receiver) &#123; return Reflect.get(target, key, receiver) &#125;&#125;) 大家可能看到上面的代码与直接使用target[key]的方式没什么区别，但实际上Reflect的出现是为了让Object上面的操作更加规范，比如我们要判断某一个prop是否在一个对象中，通常会使用到in,即 12const obj = &#123;name: 'zhangsan'&#125;console.log('name' in obj) 但上面的操作是一种命令式的语法，通过Reflect可以将其转变为函数式的语法，显得更加规范 1Reflect.has(obj,'name') 6. 参考文章 掘金博文 MDN","comments":true,"tags":[{"name":"defineProperty","slug":"defineProperty","permalink":"https://JnathanCoder.github.io/tags/defineProperty/"},{"name":"proxy","slug":"proxy","permalink":"https://JnathanCoder.github.io/tags/proxy/"}]},{"title":"vue自定义生命周期钩子","date":"2020-08-25T09:49:19.000Z","path":"2020/08/25/vue-custom-hooks/","text":"先摘抄原作者文章中引用的话吧~ 葡萄美酒夜光杯，欲饮琵琶产品催。 客户现场君莫笑，古来埋坑几人回？ 不要吹灭你的灵感和你的想象力; 不要成为你的模型的奴隶。 ——文森特・梵高 然后也不知道说啥，来点示例代码吧 utils/emitter.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import Vue from 'vue'/** * 通知组件及其子组件页面可见状态变更 * @param &#123;String&#125; lifeCycleName 生命周期钩子名 * @param &#123;vmInstance&#125; vm 实例 */const notifyVisibilityChange = (lifeCycleName, vm) =&gt; &#123; // 生命周期函数会存在$options中，通过$options[lifeCycleName]获取生命周期 const lifeCycles = vm.$options[lifeCycleName] // 因为使用了created的合并策略，所以是一个数组 if (lifeCycles &amp;&amp; lifeCycles.length) &#123; // 遍历 lifeCycleName对应的生命周期函数列表，依次执行 lifeCycles.forEach(lifecycle =&gt; &#123; process.env.NODE_ENV !== 'production' &amp;&amp; console.info('自定义' + lifeCycleName + '生命周期钩子已触发，组件name：' + vm.$options.name) lifecycle.call(vm) &#125;) &#125; // 遍历所有的子组件，然后依次递归执行 if (vm.$children &amp;&amp; vm.$children.length) &#123; vm.$children.forEach(child =&gt; &#123; notifyVisibilityChange(lifeCycleName, child) &#125;) &#125;&#125;const CustomHooks = &#123; /** * 安装注册 */ Attach() &#123; // Vue的合并策略 const optionMergeStrategies = Vue.config.optionMergeStrategies // 定义了两个生命周期函数 pageVisible, pageHidden // 这个相当于指定 pageVisible, pageHidden 的合并策略与 created的相同（使用其他生命周期函数都一样） optionMergeStrategies.pageVisible = optionMergeStrategies.created optionMergeStrategies.pageHidden = optionMergeStrategies.created &#125;, /** * 绑定监听 * @param &#123;vmInstance&#125; rootVm 根实例 */ Observer(rootVm) &#123; window.addEventListener('visibilitychange', () =&gt; &#123; // 判断调用哪个生命周期函数 let lifeCycleName = undefined if (document.visibilityState === 'hidden') &#123; lifeCycleName = 'pageHidden' &#125; else if (document.visibilityState === 'visible') &#123; lifeCycleName = 'pageVisible' &#125; if (lifeCycleName) &#123; // 通过所有组件生命周期发生变化了 notifyVisibilityChange(lifeCycleName, rootVm) &#125; &#125;) &#125;&#125;export default CustomHooks main.js123456789101112131415import CustomHooks from '@/utils/custom-emitter'// 实例化之前进行初始化CustomHooks.Attach()/* eslint-disable no-new */const rootVm = new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;)// 实例化之后绑定监听CustomHooks.Observer(rootVm) 使用 demo.vue12345678910111213export default &#123; name: \"demo\", data() &#123; return &#123;&#125; &#125;, created() &#123;&#125;, pageVisible() &#123; // TODO 页面可见逻辑 如开启已暂停的功能 &#125;, pageHidden() &#123; // TODO 页面不可见逻辑 如暂停某些花销很大的动画、ajax轮询 &#125;&#125; 参考文章前方高能，这是最新的一波Vue实战技巧","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://JnathanCoder.github.io/tags/vue/"}]},{"title":"Vue自定义指令 image-lazyLoad","date":"2020-08-13T09:37:41.000Z","path":"2020/08/13/image-lazyload/","text":"主要使用 IntersectionObserver 的特性实现，其还能实现譬如 sticky 、上拉加载 等功能。这里只记录实现图片懒加载(图片开始出现在视口区域或者即将出现在视口区域，才开始请求图片资源，进行渲染)的自定义指令的实现代码。 imageLazyLoad.js1234567891011121314151617181920212223242526272829303132333435363738394041// 加载图片function fetchImage(target, src) &#123; const tempImg = new Image() tempImg.src = src tempImg.onload = () =&gt; &#123; target.src = src &#125;&#125;let isIntersecting = false// 创建一个监视器let observer = new IntersectionObserver( (entries) =&gt; &#123; entries.forEach( (entry) =&gt; &#123; // 已经进入视口 保证只触发一次fetchImage if (isIntersecting) return if (entry.isIntersecting) &#123; isIntersecting = true fetchImage(entry.target, entry.target.lazySrc) &#125; &#125;)&#125;, &#123; // 距离视口100px提前触发 rootMargin: '100px 0px'&#125;)export default &#123; inserted(el, binding) &#123; // 默认图片 el.src = 'http://localhost:8080/static/images/before_load.png' // 图片地址绑定在lazy-src属性上，作为中转 el.lazySrc = binding.value // 开始监听 observer.observe(el) &#125;, unbind() &#123; // 解除监听 observer.disconnect() &#125;&#125; 全局注册 main.js123import Vue from 'vue'import imageLazyLoad from './imageLazyLoad'Vue.directive('lazyLoad', imageLazyLoad) 局部注册 test.vue1234567import imageLazyLoad from &apos;./imageLazyLoad&apos;export default &#123; created() &#123;&#125;, directives: &#123; lazyLoad: imageLazyLoad &#125;&#125; 使用 test.vue1&lt;img v-lazy-load=&quot;imgSrc&quot; /&gt;","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://JnathanCoder.github.io/tags/vue/"},{"name":"自定义指令","slug":"自定义指令","permalink":"https://JnathanCoder.github.io/tags/自定义指令/"},{"name":"lazy","slug":"lazy","permalink":"https://JnathanCoder.github.io/tags/lazy/"}]},{"title":"Web Worker 简介","date":"2020-08-13T08:22:26.000Z","path":"2020/08/13/web-worker/","text":"背景 JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。 基本用法1const worker = new Worker(jsUrl[, &#123; name: 'yourWorkerName' &#125;]) Tips 分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。 Worker 线程所在的全局对象，与主线程不一样，不能使用 document、window、parent、alert()、confirm()，但是可以使用 console，并且使用 XMLHttpRequest 发起 AJAX 请求。 通过 importScript 加载进来的脚本文件里，同样不能使用 alert 等属性。加载多个脚本文件时，用逗号隔开。 Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。 主线程 API12345Worker.onerror(): 指定 error 事件的监听函数Worker.onmessage(): 指定 message 事件的监听函数Worker.onmessageerror(): 指定 messageerror 事件的监听函数Worker.postMessage(): 向 Worker 线程发送消息Worker.terminate(): 终止 Worker 线程 Worker线程 API123456self.name: Worker 的名字。该属性只读，由构造函数指定self.onmessage: 指定 message 事件的监听函数self.onmessageerror: 指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件self.close(): 关闭 Worker 线程self.postMessage(): 向产生这个 Worker 线程发送消息self.importScripts(): 加载 JS 脚本 示例worker.html12345678910111213141516171819202122232425&lt;input type=\"text\" class=\"text\"&gt;&lt;input type=\"button\" class=\"button\" value=\"发送\"&gt;const text = document.querySelector('.text')const button = document.querySelector('.button')const worker = new Worker('./worker.js', &#123; name: 'myworker' &#125;)worker.onmessage = function(event) &#123; console.log('主线程收到来自myworker线程传递的消息：', event.data) console.log('------------') worker.terminate() console.log('主线程终止myworker线程')&#125;// 当向myworker传递的消息无法序列化为字符串时 触发worker.onmessageerror = function(event) &#123; // ...&#125;worker.onerror = function() &#123; // ...&#125;button.addEventListener('click', () =&gt; &#123; console.log('主线程向myworker线程发送消息：', text.value) worker.postMessage(text.value)&#125;) worker.js1234567891011121314151617181920// 均输出 myworkerconsole.log(self.name, this.name, name)importScripts('./test-importScript.js')this.onmessage = function(event) &#123; console.log('myworker线程收到主线程传递的消息：', event.data) this.postMessage('myworker线程已收到主线程传递的消息') this.close() console.log('---------') console.log('myworker线程已主动断开与主线程的连接，不能再收到传递的消息')&#125;// 当向主线程传递的消息无法序列化为字符串时 触发this.onmessageerror = function() &#123; // ...&#125; test-importScript.js12// myworkerconsole.log(this.name) 参考Web Worker 使用教程 - 阮一峰","comments":true,"tags":[{"name":"worker","slug":"worker","permalink":"https://JnathanCoder.github.io/tags/worker/"},{"name":"web-worker","slug":"web-worker","permalink":"https://JnathanCoder.github.io/tags/web-worker/"}]},{"title":"== 和 ===","date":"2020-04-29T03:10:04.000Z","path":"2020/04/29/abstract-and-strict-equality/","text":"先来几个例子，带着问题一起思考：12345678910111213console.log([10] == 10); // trueconsole.log('10' == 10); // trueconsole.log([] == 0); // trueconsole.log(true == 1); // trueconsole.log([] == false); // trueconsole.log(![] == false); // trueconsole.log([] == ![]); // trueconsole.log('' == 0); // trueconsole.log('' == false); // trueconsole.log(null == false); // falseconsole.log(null == true); // falseconsole.log(!null == true); // trueconsole.log(null == undefined); // true 1. === (strict equality comparision)12345678910111213141516171819202122if (Type(x) !== Type(y)) return falseif (Type(x) === Type(y)) &#123; if (Type(x) === Undefined) return true if (Type(x) === Null) return true if (Type(x) === String) &#123; return 长度和对应位置上字符都相同 ? true : false &#125; if (Type(x) === Boolean) &#123; return xy同时为true或false ? true : false &#125; if (Type(x) === Symbol) &#123; return 同一个Symbol ? true : false &#125; if (Type(x) === Number) &#123; if (x === NaN) return false if (y === NaN) return false if (xy相等 例如 x = 8, y = 8) return true if (x = 0, y = -0) return true if (x = -0, y = 0) return true return false // 其他情况均返回false &#125;&#125; 2. == (abstract equality comparision)123456789101112if (Type(x) === Type(y)) return x === yif (Type(x) !== Type(y)) &#123; if (x === null &amp;&amp; y === undefined) return true if (x === undefined &amp;&amp; y === null) return true if (Type(x) === Number &amp;&amp; Type(y) === String) return x == ToNumber(y) if (Type(x) === String &amp;&amp; Type(y) === Number) return ToNumber(x) == y if (Type(x) === Boolean) return ToNumber(x) == y if (Type(y) === Boolean) return x == ToNumber(y) if ([String, Number, Symbol].includes(Type(x)) &amp;&amp; Type(y) === Object) return x == ToPrimitive(y) if (Type(x) === Object &amp;&amp; [String, Number, Symbol].includes(Type(y))) return ToPrimitive(x) == y return false // 其他情况均返回false&#125; Type(x) 获取x的类型 ToNumber(x) 将x转换成Number类型 ToBoolean(x) 将x转换成Boolean类型 ToString(x) 将x转换成String类型 ToPrimitive(x) 将x转换成原始值 3. ToPrimitive()方法 - ECMAScript规范中的抽象方法，Javascript不能访问先了解js中的原始类型： Null: null Undefined: undefined Number: 如 0、8、5.5、NaN、Infinite Boolean: true、false String: 如 ‘abc’、’’ 其余都属于’非原始类型’，如 Array、Object、Function typeof null 得到的结果是object, 这是js在设计之初的问题。但null是属于原始类型的（记住就行了🐶） ToPrimitive(input[, hint])转换为原始类型的方法，根据preferedType目标类型进行转换。preferedType只能是 string 或 number 转换步骤： hint 为 number input是原始值，返回input本身 input是对象 先判断input.valueOf()的返回值。如果是原始值，返回结果。 否则，再判断input.toString()的返回值。如果是原始值，返回结果。 否则，抛出不能转换成原始值的TypeError。 hint 为 string input是原始值，返回input本身 input是对象 先判断input.toString()的返回值。如果是原始值，返回结果。 否则，再判断input.valueOf()的返回值。如果是原始值，返回结果。 否则，抛出不能转换成原始值的TypeError。 hint 为空 input 是 Date 日期类型 input被认为是string。 先判断input.toString()的返回值。如果是原始值，返回结果。 否则，再判断input.valueOf()的返回值。如果是原始值，返回结果。 否则，抛出不能转换成原始值的TypeError。 input 是 非Date 类型 input被认为是number。 先判断input.valueOf()的返回值。如果是原始值，返回结果。 否则，再判断input.toString()的返回值。如果是原始值，返回结果。 否则，抛出不能转换成原始值的TypeError。 当调用ToPrimitive而没有传hint参数时，默认情况下hint将被赋值Number。但是可以重写对象的@@toPrimitive方法来覆盖这个行为。在本规范中，只有Date和Symbol两个对象重写了默认的ToPrimitive操作。对于Date对象，如果没有传hint，hint将被默认赋值为String 示例1：ToPrimitive([10])123456// 没有传入hint参数，并且input是Array, 所以hint被赋值为Number// 先判断valueOf()[10].valueOf() 等于 [10]，属于 Array/Object，不是原始类型// 再判断toString()[10].toString() 等于 '10'，属于 String，是原始类型所以 return '10' 示例2：ToPrimitive(function sayHi(){})123456789var sayHi = function (name) &#123; console.log('hi, ' + name)&#125;// 没有传入hint参数，并且input是Function, 所以hint被赋值为Number// 先判断valueOf() typeof sayHi.valueOf === 'function'sayHi.valueOf() 等于 f (name) &#123; console.log('hi, ' + name) &#125; 属于Function，不是原始类型// 再判断toString() typeof sayHi.toString === 'string'sayHi.toString() 等于 function (name) &#123; console.log('hi, ' + name) &#125; 属于String，是原始类型所以 return sayHi方法的方法体源码字符串 上面示例中 [10] == 10 Type(x) === Object, Type(y) === Number，变成比较 ToPrimitive([10]) == 10 由示例1 知道 ToPrimitive([10]) === ‘10’，变成比较 ‘10’ == 10 此时，Type(x) === String, Type(y) === Number，变成比较 ToNumber(‘10’) == 10 ToNumber(‘10’) === 10，变成比较 10 == 10 return true [] == 0 Type(x) === Object, Type(y) === Number, 变成比较 ToPrimitive([]) == 0 没有传入hint参数，[]不属于Date类型，hint被赋值Number Number hint先判断 valueOf()， [].valueOf()返回数组本身，不是原始类型 再判断toString()，[].toString() === ‘’，属于原始类型 return ‘’ 等式变成 ‘’ == 0 此时，Type(x) === String, Type(y) === Number, 变成比较ToNumber(‘’) == 0 ToNumber(‘’) === 0, 变成比较 0 == 0 return true 按照上述步骤推导，不难可以得到： [] == false 返回true那么 ![] == false 应该返回 false吧！ 在控制台验证一下 ![] == false 返回true。纳尼！！ ![] 先转换成 Boolean。 Boolean([]) === true, ![] === false 此时变成 false == false return true 由 [] == false 返回true 和 ![] == false 返回true 得到 [] == ![] 返回 true。 🐶 null == false 走的是最后一步，不满足任何条件，直接返回false，这一说法没有理解。难道不是Type(false) === Boolean然后比较 null == 0么。。。 再就是ToPrimitive(null) == 0 ?? 炸裂，我太难了。 4. toString()方法 可以将除(null和undefined)之外的数据类型转为字符串 123456789101112[].toString() // \"\"[3, 8].toString() // \"3, 8\"new Date().toString() // Fri May 01 2020 14:24:34 GMT+0800 (中国标准时间)\"/abc/ig.toString() // \"/abc/ig\"(16).toString() // '16'(16).toString(2) // '10000' 二进制(2-35都可)(16).toString(8) // '20' 八进制(16).toString(16) // '10' 十六进制0.000006.toString() // '0.000006'0.0000006.toString() // '6e-7' 小数点后面6个或以上0时 小数采用e表示法输出(1234567890123456789012).toString() // '1.2345678901234568e+21' 整数部分超过21位，采用e表示法 可以用toString()区分自定义方法和原生方法123function fn () &#123;&#125;fn.toString() // \"function fn () &#123;&#125;\" -- fn 是自定义方法Number.toString() // \"function Number() &#123; [native code] &#125;\" -- Number是一个原生方法 还可以用Object.prototype上的原生toString()方法判断数据类型12345Object.prototype.toString.call('abc'); // \"[object String]\"Object.prototype.toString.call(123); // \"[object Number]\"Object.prototype.toString.call(true); // \"[object Boolean]\"Object.prototype.toString.call(null) // \"[object Null]\"Object.prototype.toString.call(undefined) //”[object Undefined]\" 判断原生引用类型12345678910111213141516171819202122// 函数类型function fn()&#123;console.log('test')&#125;Object.prototype.toString.call(fn) // \"[object Function]\"// 日期类型var date = new Date()Object.prototype.toString.call(date) // \"[object Date]\"// 数组类型var arr = [1,2,3]Object.prototype.toString.call(arr) // \"[object Array]\"// 正则表达式var reg = /[hbc]at/giObject.prototype.toString.call(reg) // \"[object RegExp]\"// 自定义类型function Person(name) &#123; this.name = name&#125;var person = new Person(\"Rose\")Object.prototype.toString.call(person) // \"[object Object]\" 5. String()方法 如果有toString()方法，则调用该方法，并返回结果 否则： 如果是null，返回”null” 如果是undefined，返回”undefined” 要区分toString()和String() toString(radix)支持传入radix进制参数 toString不支持null和undifined调用 String(null) === ‘null’ String(undifined) === ‘undefined’ 6. Number()方法 布尔值：true - 1 false - 0 数字值：返回数字本身 null：返回0 undefined: 返回NaN 字符串： 只包含数字：转换成十进制，忽略前导0 包含有效的浮点格式：转换成浮点数职，忽略前导0 空字符串：返回0 其他情况：返回NaN 对象：调用对象的valueOf()方法，然后依据前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，再次依照前面的规则转换返回的字符串值。 7. Boolean()方法以下值会被转换为false：false、&quot;&quot;、0、-0、NaN、null、undefined，其余任何值都会被转换为true。另外Boolean()不传递参数时，也返回false。 8. 隐式转换在某些情况下，即使我们不提供显示转换，Javascript也会进行自动类型转换，主要情况有： 8.1 用于检测是否为非数值的函数：isNaN(mix)isNaN()函数，会尝试将参数值用Number()进行转换，如果结果为“非数值”则返回true，否则返回false。 8.2 递增递减操作符（包括前置和后置）、一元正负符号操作符这些操作符适用于任何数据类型的值，针对不同类型的值，该操作符遵循以下规则（经过对比发现，其规则与Number()规则基本相同）： 如果是包含有效数字字符的字符串，先将其转换为数字值（转换规则同Number()），在执行加减1的操作，字符串变量变为数值变量。 如果是不包含有效数字字符的字符串，将变量的值设置为NaN，字符串变量变成数值变量。 如果是布尔值false，先将其转换为0再执行加减1的操作，布尔值变量编程数值变量。 如果是布尔值true，先将其转换为1再执行加减1的操作，布尔值变量变成数值变量。 如果是浮点数值，执行加减1的操作。 如果是对象，先调用对象的valueOf()方法，然后对该返回值应用前面的规则。如果结果是NaN，则调用toString()方法后再应用前面的规则。对象变量变成数值变量。 8.3 加法运算操作符 如果两个操作值都是数值，其规则为： 如果一个操作数为NaN，则结果为NaN 如果是Infinity+Infinity，结果是Infinity 如果是-Infinity+(-Infinity)，结果是-Infinity 如果是Infinity+(-Infinity)，结果是NaN 如果是+0+(+0)，结果为+0 如果是(-0)+(-0)，结果为-0 如果是(+0)+(-0)，结果为+0 如果有一个操作值为字符串，则： 如果两个操作值都是字符串，则将它们拼接起来 如果只有一个操作值为字符串，则将另外操作值转换为字符串，然后拼接起来 如果一个操作数是对象、数值或者布尔值，则调用toString()方法取得字符串值，然后再应用前面的字符串规则。对于undefined和null，分别调用String()显式转换为字符串。 可以看出，加法运算中，如果有一个操作值为字符串类型，则将另一个操作值转换为字符串，最后连接起来。 8.4 乘除、减号运算符、取模运算符这些操作符针对的是运算，所以他们具有共同性：如果操作值之一不是数值，则被隐式调用Number()函数进行转换。具体每一种运算的详细规则请参考ECMAScript中的定义 8.5 逻辑操作符（!、&amp;&amp;、||）逻辑非（！）操作符首先通过Boolean()函数将它的操作值转换为布尔值，然后求反。 逻辑与（&amp;&amp;）操作符，如果一个操作值不是布尔值时，遵循以下规则进行转换： 如果第一个操作数经Boolean()转换后为true，则返回第二个操作值，否则返回第一个值（不是Boolean()转换后的值） 如果有一个操作值为null，返回null 如果有一个操作值为NaN，返回NaN 如果有一个操作值为undefined，返回undefined 逻辑或（||）操作符，如果一个操作值不是布尔值，遵循以下规则： 如果第一个操作值经Boolean()转换后为false，则返回第二个操作值，否则返回第一个操作值（不是Boolean()转换后的值） 对于undefined、null和NaN的处理规则与逻辑与（&amp;&amp;）相同 8.6 关系操作符（&lt;, &gt;, &lt;=, &gt;=） 如果两个操作值都是数值，则进行数值比较 如果两个操作值都是字符串，则比较字符串对应的字符编码值 如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较 如果一个操作数是对象，则调用valueOf()方法（如果对象没有valueOf()方法则调用toString()方法），得到的结果按照前面的规则执行比较 如果一个操作值是布尔值，则将其转换为数值，再进行比较 注：NaN是非常特殊的值，它不和任何类型的值相等，包括它自己，同时它与任何类型的值比较大小时都返回false。 8.7 相等操作符相应规则见文章最初始。 9. 位运算符9.1 按位与(&amp;)9.2 按位与(|)9.3 按位非(~)9.4 按位异或(^)9.5 左移(&lt;&lt;) 该操作符会将左边操作数向左移动右边操作数的位数。向左被移出的位被丢弃，右侧用 0 补充。3 &lt;&lt; 2 = 3 * 2 ^ 2 = 12 9.6 有符号右移(&lt;&lt;) 该操作符会将左边操作数向右移动右边操作数的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。12 &gt;&gt; 2 = 12 / 2 ^ 2 = 3 9.6 无符号右移(&lt;&lt;&lt;) 该操作符会将左边操作数向右移动右边操作数的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。） 10. 参考文章 文章一 文章二 文章三","comments":true,"tags":[{"name":"==","slug":"","permalink":"https://JnathanCoder.github.io/tags//"},{"name":"===","slug":"","permalink":"https://JnathanCoder.github.io/tags//"},{"name":"操作符","slug":"操作符","permalink":"https://JnathanCoder.github.io/tags/操作符/"},{"name":"转换","slug":"转换","permalink":"https://JnathanCoder.github.io/tags/转换/"}]},{"title":"数据类型转换","date":"2020-04-18T16:00:00.000Z","path":"2020/04/19/data-type-transfer/","text":"基本数据类型有 Number、 String、 Boolean、 Null、 Undefined、Object，ES6新增了Symbol 类型。 1. 原始值转布尔在Javascript中。只有6种值可以被转换成false，其余均为true：false、undefined、null、NaN、0、&#39;&#39; 12345678console.log(Boolean(false)) // falseconsole.log(Boolean(undefined)) // falseconsole.log(Boolean(null)) // falseconsole.log(Boolean(NaN)) // falseconsole.log(Boolean(0)) // falseconsole.log(Boolean('')) // false// Boolean不传任何参数时 返回falseconsole.log(Boolean()) // false 2. 原始值转数字使用Number函数将数据转换成数字类型，参数无法转换成数字的，返回NaN。根据规范，如果Number函数不传参数，返回0，如果有参数，调用toNumber(value),其对应结果如下： 参数类型 结果 undefined NaN null 0 布尔值 true: 1, false: 0 Number 对应的值 String 比较复杂，看具体例子 12345678910111213141516171819console.log(Number()) // 0console.log(Number(undefined)) // NaNconsole.log(Number(null)) // 0console.log(Number(true)) // 1console.log(Number(false)) // 0console.log(Number(88)) // 88console.log(Number(\"123\")) // 123console.log(Number(\"-123\")) // -123console.log(Number(\"1.2\")) // 1.2console.log(Number(\"000123\")) // 123console.log(Number(\"-000123\")) // -123console.log(Number(\"0x11\")) // 17console.log(Number(\"\")) // 0console.log(Number(\" \")) // 0console.log(Number(\"123 123\")) // NaNconsole.log(Number(\"foo\")) // NaNconsole.log(Number(\"100a\")) // NaN 如果通过 Number 转换函数传入一个字符串，它会试图将其转换成一个整数或浮点数，而且会忽略所有前导的 0，如果有一个字符不是数字，结果都会返回 NaN。如果字符串前缀是0x或者0X，将转换为十六进制数。 3. 原始值转字符使用 String 函数将类型转换成字符串类型。根据规范，如果不传递参数，返回空字符串，如果有参数，调用toString(value)，其对应结果如下： 参数类型 结果 undefined “undefined” null “null” Boolean true: “true”, false: “false” Number 比较复杂，看具体例子 String 对应的值 1234567891011121314console.log(String()) // 空字符串console.log(String(undefined)) // undefinedconsole.log(String(null)) // nullconsole.log(String(false)) // falseconsole.log(String(true)) // trueconsole.log(String('678')) // 678console.log(String(0)) // 0console.log(String(-0)) // 0console.log(String(NaN)) // NaNconsole.log(String(Infinity)) // Infinityconsole.log(String(-Infinity)) // -Infinityconsole.log(String(1)) // 1 注意这里的 ToString 和上一节的 ToNumber 都是底层规范实现的方法，并没有直接暴露出来。 4. 对象转字符串和数字几种基本数据类型中，除了Null和Undefined类型外，其余5种原型链上都有valueOf()和toString()函数。这两个函数主要在隐式类型转换时会被自动调用。 4.1 同时重写对象的toString方法和valueOf方法1234567891011121314151617181920212223var aaa = &#123; i: 10, valueOf: function() &#123; console.log('调用valueOf...') return this.i + 30 &#125;, toString: function() &#123; console.log('调用toString...') return this.i + 10 &#125;&#125;console.log(aaa &gt; 20); // 调用valueOf... trueconsole.log('' + aaa); // 调用valueOf... 40console.log(++aaa); // 调用valueOf... 41// 在不执行上一步 console.log(++aaa) 的前提console.log(+aaa); // 调用valueOf... 40// 在执行上一步 console.log(++aaa) 的前提 此时aaa变成了字符串41console.log(+aaa); // 41 调用原型链上默认的valueOf()console.log(aaa == 40) // 调用valueOf... true// 上面的步骤没执行的前提下 否则aaa变成了字符串41 此时输出41console.log(aaa); // &#123;i: 10, valueOf: ƒ, toString: f&#125;console.log(String(aaa)) // 调用toString... 20 总结：涉及到操作符的问题，valueOf的优先级更高；涉及到显示问题，toString方法优先级更高。 4.2 只重写toString方法12345678910111213141516171819var bbb = &#123; i: 10, toString: function() &#123; console.log('调用toString...') return this.i + 10 &#125;&#125;console.log(bbb &gt; 20); // 调用toString... falseconsole.log('' + bbb); // 调用toString... 20console.log(++bbb); // 调用toString... 21// 在不执行上一步 console.log(++bbb) 的前提console.log(+bbb); // 调用toString... 20// 在执行上一步 console.log(++bbb) 的前提 此时bbb变成了字符串21console.log(+bbb); // 21 调用原型链上默认的valueOf()console.log(bbb == 20) // 调用toString... true// console.log(bbb); // &#123;i: 10, toString: ƒ&#125; 没调用重写的toString()方法，调用了原型链上默认的valueOf()console.log(String(bbb)) // 调用toString... 20 总结： toString方法比原型链上的valueOf方法优先级高","comments":true,"tags":[{"name":"数据类型","slug":"数据类型","permalink":"https://JnathanCoder.github.io/tags/数据类型/"},{"name":"类型转换","slug":"类型转换","permalink":"https://JnathanCoder.github.io/tags/类型转换/"}]},{"title":"移动端真机调试 spy-debugger","date":"2019-07-15T08:53:26.000Z","path":"2019/07/15/spy-debugger/","text":"关于spy-debugger一站式页面调试、抓包工具。远程调试任何手机浏览器页面，任何手机移动端webview（如：微信，HybridApp等）。支持HTTP/HTTPS，无需USB连接设备。 特性1、页面调试＋抓包2、操作简单，无需USB连接设备3、支持HTTPS。4、spy-debugger内部集成了weinre、node-mitmproxy、AnyProxy。5、自动忽略原生App发起的https请求，只拦截webview发起的https请求。对使用了SSL pinning技术的原生App不造成任何影响。6、可以配合其它代理工具一起使用(默认使用AnyProxy) (设置外部代理) 安装1[sudo] npm install spy-debugger -g 三分钟上手第一步：手机和PC保持在同一网络下（比如同时连到一个Wi-Fi下）第二步：命令行输入spy-debugger，按命令行提示用浏览器打开相应地址。第三步：设置手机的HTTP代理，代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)。 Android设置代理步骤：设置 - WLAN - 长按选中网络 - 修改网络 - 高级 - 代理设置 - 手动iOS设置代理步骤：设置 - 无线局域网 - 选中网络 - HTTP代理手动 第四步：手机安装证书。 spy-debugger initCA 会将证书放置到系统根目录node-mitmproxy文件夹。Mac 如：/users/yourName/node-mitmproxyWindows 如：C/users/yourName/node-mitmproxy将文件夹下的node-mitmproxy.ca.crt到手机上安装 第五步：用手机浏览器访问你要调试的页面即可。 效果截图 自定义选项端口(默认端口9888)1spy-debugger -p 9999 设置外部代理（默认使用AnyProxy）1spy-debugger -e http://127.0.0.1:8888 设置页面内容为可编辑模式（默认false）1spy-debugger -w true 该功能使页面内容修改更加直观方便。内部实现原理：在需要调试的页面内注入代码：document.body.contentEditable=true。暂不支持使用了iscroll框架的页面。 是否允许weinre监控iframe加载的页面(默认false)1spy-debugger -i true 是否只拦截浏览器发起的https请求（默认true）1spy-debugger -b false 是否允许HTTP缓存(默认false)1spy-debugger -c true","comments":true,"tags":[]},{"title":"知识点","date":"2019-06-06T08:48:44.000Z","path":"2019/06/06/brief-info/","text":"1. 一些js插件为什么以;开头因为js代码允许在结束的时候不添加;, 所以两个js文件在合并拼接的的时候可能出错。 12345678// a.js// 末尾没有添加;符号var a = 'test'// b.js(function()&#123; // do something&#125;)(); 以上两个文件进行合并压缩的时候就可能变为： 123var a = 'test'(function()&#123;&#125;)();// 这样会报错： TypeError: 'test' is not a function 2. 使用闭包定义私有属性123456789101112131415161718function Product() &#123; var name; this.setName = function(value) &#123; name = value; &#125;; this.getName = function() &#123; return name; &#125;;&#125;var p = new Product();p.setName(\"test\");console.log(p.name); // 输出undefinedconsole.log(p.getName()); // 输出test 代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。 3. 枚举属性 可枚举性在js中，基本数据类型的原型属性是不可枚举的，比如Object、Array、Number等。 12345// 打印结果为空 Number内置属性是不可枚举的var num = new Number()for (let i in num) &#123; console.log(i, num[i])&#125; propertyIsEnumerable Object.propertyIsEnumerable(prop)prop 需要测试的属性名返回值 用来表示指定的属性名是否可枚举的Boolean属性必须满足 自身属性 &amp;&amp; 枚举属性，才会返回true 1234567var obj = &#123;&#125;obj.test = 'Jnathan'var arr = [23, 67]obj.propertyIsEnumerable('test') // truearr.propertyIsEnumerable(0) // truearr.propertyIsEnumerable(1) // true hasOwnProperty Object.hasOwnProperty(prop)prop 需要测试的属性名返回值 用来表示指定的属性名是否在对象中的Boolean 1234567var obj = &#123;&#125;obj.x = 'Jnathan'obj.y = function() &#123;&#125;obj.hasOwnProperty('x') // trueobj.hasOwnProperty('y') // true 方法也属于属性obj.hasOwnProperty('z') // false 属性不存在obj.hasOwnProperty('toString') // false toString是继承的Object中的属性，obj自身属性中不包含 123456789101112function Person() &#123; this.name = 'Jnathan'&#125;Person.prototype = &#123; constructor: Person, job: 'student',&#125;var Jnathan = new Person()Object.defineProperty(Jnathan, \"gender\", &#123; value: 'female', enumerable: false&#125;) 以上， 用defineProperty为对象Jnathan定义了一个名为gender的不可枚举属性 枚举 for…in 123456789101112131415161718192021222324for (let item in Jnathan) &#123; console.log('Jnathan.' + item + ' = ' + Jnathan[item])&#125;// Jnathan.name = Jnathan// Jnathan.constructor = function Person() &#123;// this.name = 'Jnathan'// &#125;// Jnathan.job = studentfunction enumer() &#123; this.a = '我是对象本身就有的属性'&#125;enumer.prototype.b = '我是通过原型对象挂载的属性'let fn = new enumer()Object.defineProperty(fn, 'c', &#123; value: '我是通过Object.defineProperty方法添加的可枚举属性', enumerable: true&#125;);for(let item in fn) &#123; console.log(item)&#125;// a// b// c 枚举 Object.keys() 1234567891011121314Object.keys(Jnathan)// [\"name\"]function enumer() &#123; this.a = '我是对象本身就有的属性'&#125;enumer.prototype.b = '我是通过原型对象挂载的属性'let fn = new enumer()Object.defineProperty(fn, 'c', &#123; value: '我是通过Object.defineProperty方法添加的可枚举属性', enumerable: true&#125;);console.log(Object.keys(fn))// [\"a\", \"c\"] 枚举 JSON.stringify() 1234567891011121314JSON.stringify(Jnathan)// \"&#123;\"name\":\"Jnathan\"&#125;\"function enumer() &#123; this.a = '我是对象本身就有的属性'&#125;enumer.prototype.b = '我是通过原型对象挂载的属性'let fn = new enumer()Object.defineProperty(fn, 'c', &#123; value: '我是通过Object.defineProperty方法添加的可枚举属性', enumerable: true&#125;)console.log(JSON.stringify(fn))// &#123;\"a\":\"我是对象本身就有的属性\",\"c\":\"我是通过Object.defineProperty方法添加的可枚举属性\"&#125; 根据现象有以下总结for…in 可以枚举对象本身具有的属性，通过Object.defineProperty()方法加的可枚举属性，或者通过原型对象绑定的可以枚举属性Object.keys() 可以枚举对象本身的属性和通过Object.defineProperty()添加的可枚举属性JSON.stringify() 可以枚举对象本身的属性和通过Object.defineProperty()添加的可枚举属性，并序列化为JSON字符串 !== undefined 1234567var obj = &#123;x: 1, y: undefined, z: null&#125;console.log(obj.x !== undefined) // true 属性存在console.log(obj.y !== undefined) // false 此时会出现歧义，不能准确判断属性是不存在还是属性值本身就为undefinedconsole.log(obj.z !== undefined) // true 属性存在console.log(obj.z != undefined) // false != 不能区分undefined和null，将两者同等对待console.log(obj.w !== undefined) // false 属性不存在console.log(obj.toString !== undefined) // true 存在toString函数属性。 in 自身存在的属性或者继承的属性均返回true 123456var obj = &#123;x: 1, y: undefined, z: null&#125;console.log(\"x\" in obj) // true 属性存在console.log(\"y\" in obj) // true 属性存在console.log(\"z\" in obj) // true 属性存在console.log(\"w\" in obj) // false 属性不存在console.log(\"toString\" in obj) // true 属性存在 Object.defineProperty() 参数：Object.defineProperty(object, propertyname, descriptor)object 必需。 要在其上添加或修改属性的对象。 这可能是一个本机 JavaScript 对象（即用户定义的对象或内置对象）或 DOM 对象。propertyname 必需。 一个包含属性名称的字符串。descriptor 必需。 属性描述符。 它可以针对数据属性或访问器属性。返回值：已修改对象 当对象不具有指定的属性名称时，向对象添加新属性。当对象已具有指定的属性名称时，修改现有属性的特性。 12345678910var obj = &#123;&#125;Object.defineProperty(obj, \"newDataProperty\", &#123; value: 101, writable: false, enumerable: false, configurable: true&#125;);obj.newDataProperty = 102console.log(obj.newDataProperty) // 101 whiteable为false 只读，不能修改 Object.getOwnPropertyNames 由于obj的属性newDataProperty是不可枚举的，使用for…in不能找到newDataProperty属性 123for (let item in obj) &#123; console.log(item, obj[item]) // 无输出&#125; 此时可以使用Object.getOwnPropertyNames来遍历 12345var names = Object.getOwnPropertyNames(obj)for (let i = 0; i &lt; names.e]length; names++) &#123; console.log(names, i, names[i])&#125;// [\"newDataProperty\"] 0 newDataProperty 12345678910111213141516171819var obj = &#123;&#125;Object.defineProperty(obj, \"newAccessorProperty\", &#123; set: function (x) &#123; console.log(\"in property set accessor\"); this.newaccpropvalue = x; &#125;, get: function () &#123; console.log(\"in property get accessor\"); return this.newaccpropvalue; &#125;, enumerable: true, configurable: true&#125;);obj.newAccessorProperty = 30console.log(\"Property value: \" + obj.newAccessorProperty)// in property set accessor// in property get accessor// Property value: 30 修改DOM上的属性 12Object.getOwnPropertyDescriptor(Element.prototype, \"querySelector\")// &#123;value: ƒ, writable: true, enumerable: true, configurable: true&#125; 1234567891011var descriptor = Object.getOwnPropertyDescriptor(Element.prototype, \"querySelector\")descriptor.value = \"query\"descriptor.writable = falseObject.defineProperty(Element.prototype, \"querySelector\", descriptor)var elem = document.getElementById(\"div\")elem.querySelector = \"anotherQuery\" // whitable 为false 更改不生效console.log(elem.querySelector) // query","comments":true,"tags":[]},{"title":"日志内容【二】","date":"2019-05-26T06:08:31.000Z","path":"2019/05/26/multiple-diary2/","text":"1. substr() 和 substring() substr stringObject.substr(startIndex[, length]) 12345678var str = ‘abcdefg'str.substr(2) // ‘cdefg’str.substr(-1) =&gt; str.substr(6) // ‘fg’str.substr(6) // ‘'str.substr(2,2) // ‘cd’str.substr(2,7) // ‘cdefg’str.substr(2,-1) // '' substring stringObject.substring(startIndex[, stop]) 注意stop的含义 1234567var str = ‘abcdefg'str.substring(2) // ‘cdefg’str.substring(2,4) // ‘cd’str.substring(2,9) // ‘cdefg’str.substring(-2) =&gt; str.substring(0) // ‘abcdefg’str.substring(2,-4) =&gt; str.substring(2,0) =&gt; str.substring(0,2) // ‘ab' 2. slice() 和 splice() slice stringObject.slice(startIndex[, stop])arrayObject.slice(startIndex[, stop])stop 缺省时 默认一直到最后 12345678910111213var str = ‘abcdefg’str.slice(2) // ‘cdefg'str.slice(0) // ‘abcdefg’str.slice(-2) =&gt; str.slice(5) // ‘fg’str.slice(8) // ‘’ 空串 str.slice(2,4) // ‘cd’str.slice(2,6) // ‘cdef’str.slice(2,18) // ‘cdefg’str.slice(4,2) // ‘’ 空串str.slice(4,-1) =&gt; str.slice(4,6) // ‘ef’// 数组方法类似 splice arrayObject.splice(startIndex, length[, item1, item2…])splice操作会改变原数组 返回被移除的元素数组 12345678var arr = [‘a’,’b’,’c’,’d’,’e’,’f’,’g’]arr.splice(2,0) // 空数组 arr = [‘a’,’b’,’c’,’d’,’e’,’f’,’g’]arr.splice(2,8) // arr = [‘a’, ‘b’, ‘c']arr.splice(2,-5) // 返回arr arr没有变化arr.splice(8,2) // 返回arr arr没有变化arr.splice(2,2,'11',’22') // 返回[‘a’, ‘b’, ’11’, ’22’, ‘e’, ‘f’, ‘g’] arr = [‘c’, ‘d'] 3. 检测数据类型 typeof typeof 是解释器内部实现，根据 ECMA-262 规定的几种类型的值来返回类型名称。但是 typeof 的应用场景非常有限，基本上只能判断出来使用字面量方式赋值的基本数据类型。 12345678910typeof 23 // numbertypeof '124' // stringtypeof true // booleantypeof undefined // undefinedtypeof &#123;&#125; // objecttypeof null // objecttypeof [1, 3, 8] // objecttypeof function fn () &#123;&#125; // functiontypeof (new Number(33)) // objecttypeof (new String('hello')) // object 从上面例子可以看出， typeof 检测出来的类型不够准确，具有相当大的局限性。 instanceof instance 检测类型的原理大致为: 判断左边的对象的隐式原型 proto 是否和右边对象的显式原型 prototype 相等。 很像 new 操作，这样就可以判断指定的某个对象是否为某个构造函数的实例。 instance 的局限性应该是不能检测基本数据类型。另外一点，不同 window 或者 iframe 之间对象类型检测不能使用 instanceof 来检测。 1234567'123' instance String // falseNumber instanceof Number // truenew String('hello') instance String // truenew Number(33) instance Number // true Object.prototype.toString 1234567891011121314151617Object.prototype.toString.call(33) // [object Number]Object.prototype.toString.call('hello') // [object String]Object.prototype.toString.call([]) // [object Array]Object.prototype.toString.call(&#123;&#125;) // [object Object]Object.prototype.toString.call(true) // [object Boolean]Object.prototype.toString.call(null) // [object null]Object.prototype.toString.call(undefined) // [object undefined]Object.prototype.toString.call(function fn () &#123;&#125;) // [object Function]Object.prototype.toString.call(new Number(33)) // [object Number] constructor constructor 属性返回对创建此对象的数组函数的引用。constructor 不能检测出null和undefined两种，会报错。 1234567891011121314151617181920(33).constructor == Number // true('hello'.constructor == String // true([]).constructor == Array // true(&#123;&#125;).constructor == Object // true(true).constructor == Boolean // true(null).constructor == null // TypeError: Cannot read property 'constructor' of null(undefined).constructor == undefined // TypeError: Cannot read property 'constructor' of undefinedvar fn = function () &#123;&#125;fn.constructor == Function // truevar number = new Number(66)number.constructor == Number // truenumber.constructor == Object // false 我是分割线 Array.isArray() 4. ES5 Array Function forEach Array.forEach(callbackFn[, thisObj])callbackFn (value, index, arr)thisObj 默认为 window 123[1, 2, 5, 8].forEach( function (ele, index, arr) &#123; console.log(ele, index, arr)&#125;) map Array.map(callbackFn[, thisObj])callbackFn (value, index, arr) 123[1, 2, 5, 8].map(function (ele, index, arr) &#123; return ele * index // [0, 2, 10, 24]&#125;) filter Array.filter(callbackFn[, thisObj])callbackFn (value, index, arr), 需要返回 Boolean 值 1234567[0, 2, 5, 8].filter(function (ele, index, arr) &#123; return ele // [2, 5, 8]&#125;)[0, 2, 5, 1].filter(function (ele, index, arr) &#123; return ele &lt;= index // [0, 1]&#125;) some Array.some(callbackFn[, thisObj])callbackFn (value, index, arr) 123[1, 2, 5, 8].some(function (ele, index, arr) &#123; return ele &gt; 5 // true (8 &gt; 5)&#125;) every Array.every(callbackFn[, thisObj])callbackFn (value, index, arr) 123[1, 2, 5, 8].every(function (ele, index, arr) &#123; return ele &gt; 5 // false (1, 2, 5 均不大于5)&#125;) indexOf Array.indexof(searchEle[, fromIndex])第一个出现的 searchEle 的索引位置searchEle 要查找的元素fromIndex 开始查找的索引位置，缺省或不符合规范时为 0 1234[1, 2, 5, 8].indexOf(2) // 1[1, 2, 5, 8].indexOf(2, '0') // 1[1, 2, 5, 8].indexOf(2, 'f') =&gt; [1, 2, 5, 8].indexOf(2, 0) // 1[1, 2, 5, 8].indexOf(2, 2) // -1 lastIndexOf Array.lastIndexOf(searchEle[, fromIndex])与 indexOf 不同在于此方法是从后面元素开始查找的searchEle 要查找的元素fromIndex 开始查找的索引位置，缺省时或大于等于 Array.length 为 Array.length - 1 123456[1, 2, 5, 8, 5].lastIndexOf(5) // 4[1, 2, 5, 8, 5].lastIndexOf(5, 4) // 4[1, 2, 5, 8, 5].lastIndexOf(5, 8) =&gt; [1, 2, 5, 8, 5].lastIndexOf(5, 4) // 4[1, 2, 5, 8, 5].lastIndexOf(5, 'f') // -1[1, 2, 5, 8, 5].lastIndexOf(5, 3) // 2[1, 2, 5, 8, 5].lastIndexOf(5, 1) // -1 reduce Array.reduce(callbackFn[, initValue])callbackFn(previous, current, index, arr)previous 前一次迭代计算出来的值current 当前迭代的值initValue 初始值, 未指定时取数组的第一个元素 123[1, 2, 5, 8].reduce(function (preV, curV, index, arr) &#123; return preV + curV&#125;, 10) // 26 123456789101112131415// 梳理一下计算过程：// 初始化的时候preV = initValue = 10, curV = 1, index = 0// 第一次计算preV = 10 + 1 = 11, curV = 2, index = 1// 第二次计算preV = 11 + 2 = 13, curV = 5, index = 2// 第三次计算preV = 13 + 5 = 18, curV = 8, index = 3// 第四次计算preV = 18 + 8 = 26, curV = undefined (退出) reduceRight 和 reduceRight 用法基本一致，不过是从数组后面开始迭代的Array.reduceRight(callbackFn[, initValue])callbackFn(previous, current, index, arr)previous 前一次迭代计算出来的值current 当前迭代的值 123456[1, 2, 5, 8].reduceRight(function (preV, curV, index, arr) &#123; if (index == 0) &#123; return preV - curV &#125; return preV + curV&#125;, 10) // 24 123456789101112131415// 梳理一下计算过程：// 初始化的时候preV = initValue = 10, curV = 8, index = 3// 第一次计算preV = 10 + 8 = 18, curV = 5, index = 2// 第二次计算preV = 18 + 5 = 23, curV = 2, index = 1// 第三次计算preV = 23 + 2 = 25, curV = 1, index = 0// 第四次计算preV = 25 - 1 = 24, curV = undefined (退出) 参考文章","comments":true,"tags":[]},{"title":"webpack-study","date":"2019-05-23T07:29:00.000Z","path":"2019/05/23/webpack-study/","text":"webpack-dev-server-312345678910111213141516171819var devMiddleware = require('webpack-dev-middleware')(compiler, &#123; publicPath: webpackConfig.output.publicPath, hot: true, stats: &#123; colors: true, chunks: false &#125;&#125;)// use expressapp.use(devMiddleware)app.listen(port, host, function (err) &#123; if (err) &#123; console.log(err) return &#125; console.log('Listening at ' + host + ':' + port + '\\n')&#125;) CommonsChunkPlugin123456789101112131415161718192021// webpack.config.jsvar webpack = require(‘webpack’)entry: &#123; vendor: ['jquery', 'lodash'], vuecore: './vuecore.js'&#125;, plugins: [ // new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.bundle.js'), // new webpack.optimize.CommonsChunkPlugin(&#123; // name: 'vuecore', // filename: 'vuecore.js' // &#125;), // Error: CommonsChunkPlugins: While running in normal mode its not allowed to use a non-entry chunk (vuecore) // doing this instaed new webpack.optimize.CommonsChunkPlugin(&#123; names: ['vuecore','vendor'] &#125;), new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.bundle.js')]","comments":true,"tags":[{"name":"webpack","slug":"webpack","permalink":"https://JnathanCoder.github.io/tags/webpack/"}]},{"title":"日志内容【一】","date":"2019-05-22T09:43:43.000Z","path":"2019/05/22/multiple-diary/","text":"1. setTimeout中方法体添加引号与不添加引号的区别 添加引号的情况，调用的函数是全局范围的。未添加引号的情况，调用的是局部范围的。 1234567891011121314151617var testFn = function () &#123; console.info('hello from global')&#125;var fn = function () &#123; var testFn = function () &#123; console.info('hello fron inner') &#125; setTimeout('testFn()', 1000) // hello form global setTimeout(testFn, 1000) // hello from inner // 在fn()函数内部没有定义testFn的时候，会向上寻找testFn，这里找到了全局函数，执行效果： setTimeout(testFn, 1000) // hello from global&#125;fn() 2. AMD/CMD规范 common.jscommon.js 运行在服务器端，因为模块就在磁盘上，所以加载时间几乎可以忽略不计，属于同步加载。 [典型代表 node.js]AMD与CMD都属于异步加载，运行在浏览器端。AMD 推崇依赖前置，定义模块的时候就需要申明需要依赖的模块 [典型代表 require.js]CMD 推崇依赖就近，需要用到的时候才去require相关模块 [典型代表 sea.js] 3. stopPropagation() 以及 stopImmediatePropagation()stopImmediatePropagation 用于阻止冒泡，在执行完当前元素上的事件处理程序之后，停止当前元素以及后续元素的事件处理程序 stopPropagation 同样也是用于阻止冒泡，在执行完绑定到当前元素上的所有事件处理程序之后，停止后续元素的事件处理程序 同一个元素用on绑定多次同样事件时（例如click），最后一次会覆盖之前的事件，不会执行前面。而用addEventListener绑定多次同样事件时，都会执行。 12345&lt;div id=\"large\" style=\"width: 150px; height: 150px; background: orange\"&gt; &lt;div id=\"middle\" style=\"width: 100px; height: 100px; background: cadetblue\"&gt; &lt;div id=\"small\" style=\"width: 50px; height:50px; background: coral\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546(function()&#123; var large = document.getElementById('large') var middle = document.getElementById('middle') var small = document.getElementById('small') large.addEventListener('click', function()&#123; alert('large div is clicked') &#125;) middle.addEventListener('click', function()&#123; alert('middle div is clicked') &#125;) // 第一种情况： 点击small时，会依次弹出三个窗口，这是因为向上冒泡产生的 small.addEventListener('click', function()&#123; alert('small div is clicked') &#125;) // 第二种情况： 点击small时，会弹出四个窗口 // small.addEventListener('click', function()&#123; // alert('small-1 is clicked') // &#125;) // small.addEventListener('click', function()&#123; // alert('small-2 is clicked') // &#125;) // 第三种情况，添加stopPropagation： 点击small时，会弹出两个窗口 // small-1 is clicked small-2 is clicked // small.addEventListener('click', function(event)&#123; // alert('small-1 is clicked') // event.stopPropagation() // &#125;) // small.addEventListener('click', function()&#123; // alert('small-2 is clicked') // &#125;) // 第四种情况，添加stopImmediatePropagation： 点击small时，会弹出一个窗口 // small-1 is clicked // 能够很明显看到与stopPropagation的区别，调用stopImmediatePropagation之后，第二个定义的click事件也被取消而不被执行了。 // small.addEventListener('click', function(event)&#123; // alert('small-1 is clicked') // event.stopImmediatePropagation() // &#125;) // small.addEventListener('click', function()&#123; // alert('small-2 is clicked') // &#125;)&#125;)() (function(){ var large = document.getElementById('large') var middle = document.getElementById('middle') var small = document.getElementById('small') large.addEventListener('click', function(){ alert('large div is clicked') }) middle.addEventListener('click', function(){ alert('middle div is clicked') }) // 第一种情况： 点击small时，会依次弹出三个窗口，这是因为向上冒泡产生的 small.addEventListener('click', function(){ alert('small div is clicked') }) // 第二种情况： 点击small时，会弹出四个窗口 // small.addEventListener('click', function(){ // alert('small-1 is clicked') // }) // small.addEventListener('click', function(){ // alert('small-2 is clicked') // }) // 第三种情况，添加stopPropagation： 点击small时，会弹出两个窗口 // small-1 is clicked small-2 is clicked // small.addEventListener('click', function(event){ // alert('small-1 is clicked') // event.stopPropagation() // }) // small.addEventListener('click', function(){ // alert('small-2 is clicked') // }) // 第四种情况，添加stopImmediatePropagation： 点击small时，会弹出一个窗口 // small-1 is clicked // 能够很明显看到与stopPropagation的区别，调用stopImmediatePropagation之后，第二个定义的click事件也被取消而不被执行了。 // small.addEventListener('click', function(event){ // alert('small-1 is clicked') // event.stopImmediatePropagation() // }) // small.addEventListener('click', function(){ // alert('small-2 is clicked') // }) })() 4. js事件中的三个阶段三个阶段分别为捕获阶段 目标阶段 冒泡阶段element.addEventListener(type, fn[, useCapture])useCapture - 指定事件句柄在捕获阶段或者冒泡阶段执行， 默认false(事件句柄在冒泡阶段执行)，设置为true(事件句柄在捕获阶段执行)。 捕获阶段 目标阶段 冒泡阶段 5. 常见的前端性能优化手段 css sprites（雪碧图） 避免使用css表达式 css样式表放在页面顶部，脚本放在页面底部 内联图片和脚本使用data:URL（base64编码）模式直接包含在页面中，无需进行http请求，缺点：ie不支持，图片太大不适用，使用base64会增加页面体积，浏览器不会缓存 使用内容分发网络CDN 开启GZIP压缩，启用负载均衡 开启keep alive减少与服务器链接次数 缺点：使服务器负载增大，也更容易遭受攻击 精简压缩代码 uglifyjs 避免重定向 常见的301 302 配置e-tags 和 expires头 使用缓存 按需加载资源 6. parseInt() 以及 parseFloat() parseInt(string[, radix]) string如果以‘ox’或者’oX’开头，将以16进制进行解析 radix 要解析的数字基数，介于2-36之间 如果不给值或者为0，则按照基数为10来计算 如果小于2或者大于36，则返回NaN 开头和结尾的空格是允许的 如果字符串的第一个字符不能转换成对应的数字，将返回NaN 12345678910111213141516171819parseInt('0x12') // 17parseInt('0x12', 2) // 0 =&gt; parseInt('0', 2)parseInt('0x12', 10) // 0 =&gt; parseInt('0', 16)parseInt('8') // =&gt; parseInt('8', 0) =&gt; parseInt('8', 10) // 8parseInt('8', 1) // NaNparseInt('8', 37) // NaNparseInt('a23') // NaNparseInt('2a3') // 2parseInt(' 23') // 23parseInt(' 23 ') // 23parseInt(' 2 3 ') // 2parseInt('11', 2) // 3parseInt(11, 2) // 3parseInt('1100', 2) // 12parseInt('21', 2) // NaN 2超出了2进制最大值1，并且是第一个字符parseInt('12', 2) // 1 2同样超出了2进制最大值1，但是第一个字符可以转换成二进制parseInt('66', 8) // 6*8^1 + 6*8^0 = 48 + 6 = 54parseInt('12', 16) // 1*16^1 + 2*16^0 = 16 + 2 = 18[0, 1, 2, 3].map(parseInt) // [parseInt(0, 0), parseInt(1, 1), parseInt(2, 2), parseInt(3, 3)] =&gt; [0, NaN, NaN, NaN] parseFloat() parseInt(string[, radix]) 这里语法待修改 开头和结尾的空格是允许的 如果字符串的第一个字符不能转换成对应的数字，将返回NaN 如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符 7. charAt()、charCodeAt() 和 fromCharCode() charAt() String.charAt(index) 返回字符串中指定位置的字符, 索引值 index &lt; 0 或超出了范围则返回一个空字符串 123'abc'.charAt(1) // 'b''abc'.charAt(-2) // '''abc'.charAt(5) // '' charCodeAt() String.charCodeAt(index) 返回字符串中指定位置的字符的 unicode 数值 [0, 1114111] 开头的 128 个 unicode 编码单元和 ASCII 字符编码一样 索引值 index &lt; 0 或超出了范围则返回一个 NaN, 大于 255 的是中文 12345'AabcdD'.charCodeAt(0) // 65'AabcdD'.charCodeAt(1) // 97'AabcdD'.charCodeAt(-1) // NaN'AabcdD'.charCodeAt(8) // NaN'中国'.charCodeAt(1) // 22269 fromCharCode() String.fromCharCode(num1, num2, num3, …) 根据指定的 unicode 编码中的序号值来返回字符串 1String.fromCharCode(65, 66, 97) // 'ABa' 8. 原生ajax12345678910var xhr = new XMLHttpRequest()// 请求方式 请求路径 是否异步发送请求xhr.open('GET', 'http://www.jnathan.cn/jnathan/effect/authKit.js', true)xhr.send('hello world') xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // alert(xhr.responseText) &#125;&#125; 9. 有一个长度为n的数组，假定全部为整数，其中有且仅有一个数出现了奇数次，其他的数字都出现偶数次，找出出现了奇数次的那个数字。 时间复杂度为O(n) 空间复杂度O(1)利用了n ^ n = 0, n ^ 0 = n两个等式的原理。循环对数组数字进行异或计算，即 0 ^ arr[0] ^ arr[1] ^ ... ^ arr[n - 1] ，异或计算满足交换律原则，如果数组元素出现了相同的情况，可以移动到一起先进行计算，如果出现了偶数次，其结果为 0，出现了奇数次的数其结果为该数字，所以表达式最后得出来的结果即为数组所有出现了奇数次元素的异或操作的结果。比如：[1,2,2,3,4,4]进行异或操作得到的结果是 1 ^ 3 = 2 ，特殊情况下（只有一个数字出现了奇数次），那么最后的结果就是出现了奇数次的那个数字！！ 123456789function fn7 (arr) &#123; var oddTimesNumber = 0 for (let i in arr) &#123; oddTimesNumber = oddTimesNumber ^ arr[i] &#125; return oddTimesNumber&#125;fn7([1,2,3,4,5,4,4,3,2,1,1,1]) // 3 10. 递归求1-10的和123456789101112function getSum(nextArr, curSum = 0) &#123; var sum = nextArr[0] + curSum if (nextArr.length == 1) &#123; return sum &#125; else &#123; return getSum(nextArr.slice(1), sum) &#125;&#125;getSum([1,2,3,4,5,6,7,8,9,10]) 11. 去除数组重复元素 直接双层循环比较 123456789101112131415161718192021222324function unique (arr) &#123; var result = [] var isRepeat for (var i = 0; i &lt; arr.length; i++) &#123; isRepeat = false // 默认不重复，进行push操作，当判断重复时不操作 for (var j = 0; j &lt; result.length; j++) &#123; if (arr[i] === result[j]) &#123; isRepeat = true break &#125; &#125; if (!isRepeat) &#123; result.push(arr[i]) &#125; &#125; return result&#125;unique([1,1,2,3,4]) 利用indexOf()， 但是indexOf会一直循环到找到目标为止，浪费了时间 12345678910111213function unique (arr) &#123; var result = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (result.indexOf(arr[i]) === -1) &#123; result.push(arr[i]) &#125; &#125; return result&#125;unique([1,1,2,3,4]) 最快的方法 把已经出现过的元素通过下标的形式存入一个Object内。下标的引用的实现原理利用的是哈希算法，要比用indexOf()搜索数组快的多。由于多了一个hash表，占用的内存会更多，空间换时间做法 1234567891011121314function unique (arr) &#123; // hashObj为hash表，result为临时数组 var hashObj = &#123;&#125;, result = [] for (var i = 0; i &lt; arr.length; i++) &#123; // 如果hash表中没有当前项 if (!hashObj[arr[i]]) &#123; // 存入hash表 hashObj[arr[i]] = true // 把当前数组的当前项push到临时数组里面 result.push(arr[i]) &#125; &#125; return result&#125; 折衷方法 时间上比indexOf快，比hash表的方式要慢。先按照从小到大的顺序排序，然后比较相邻的两个值大小 12345678910function unique (arr) &#123; arr.sort() var result = [arr[0]] for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== result[result.length - 1]) &#123; result.push(arr[i]) &#125; &#125; return result&#125; es6的filter()方法 1234567891011121314function unique (arr) &#123; return arr.filter( (value, index) =&gt; &#123; arr.indexOf(value) === index console.log(arr.indexOf(value), index) // 0 0 // 0 1 // 2 2 // 3 3 // 4 4 // 5 5 // 2 6 &#125;)&#125;unique([1,1,2,3,4,5,2]) 12. jquery 里面的 $(document).ready(function(){}) 和 window.onload 的区别 window.onload需要等到页面中包括图片在内的元素全部加载完毕才能执行；ready()是DOM元素绘制结束之后就执行，不用等到加载完毕。 window.onload如果定义了多次，则只会执行一个，后者会覆盖前者； ready()可以同时编写多个，并且都会执行。 window.onload没有简化写法；$(document).ready(function(){})可以简化成$(function(){})。 补充：$(window).load(function(){})和 window.onload()效果一致。 13. 渐进增强与优雅降级 渐进增强 一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再对高级浏览器进行效果、交互的优化，达到更好的体验。 优雅降级 一开始就构建站点的完整功能，然后针对浏览器进行测试和修复。比如一开始使用CSS3的特性构建了一个应用，然后逐步针对各大低级浏览器进行hack使其可以在低版本浏览器上正常浏览。 14. cookies、localStorage和sessionStorage的区别 cookies存在于客户端，始终会在http请求中通过 Request Headers Cookie头携带，即使当前请求不需要使用到cookie；大小一般在4KB，所以只适合保存很小的数据，比如会话标识；cookies在没有设置过期时间（expires）的时候，默认在关闭浏览器之后就会被清除，在有设置过期时间的时候，会一直持续到过期时间有效（即使关闭当前窗口或者关闭浏览器）。 localStorage 和 sessionStorage不会发送数据到服务端，仅在本地保存；也有大小的限制，但一般在5M左右；localStorage一直有效，除非手动清除； sessionStorage只在浏览器关闭之前有效。 另外： localStorage 和 cookies 在同源的浏览器窗口之间是共享的，sessionStorage不共享，因此至少有以下两种方法实现不同页面间的通信： 利用localStorage 123456789// A页面$('#btn').click(function()&#123; localStorage.setItem('name', 'Jnathan')&#125;)// B页面window.addEventListener('storage', function(event)&#123; console.log(event.key + '=' + event.newValue)&#125;) 利用cookie + setInterval() 123456789101112// A页面$('#btn').click(function () &#123; document.cookie = \"name=\" + 'Jnathan'&#125;)// B页面function getKey(key) &#123; return JSON.parse(\"&#123;\\\"\"+ document.cookie.replace(/;\\s+/gim,\"\\\",\\\"\").replace(/=/gim, \"\\\":\\\"\") +\"\\\"&#125;\")[key]; &#125;setInterval(function()&#123; console.log('name:', getKey('name'))&#125;, 1000) 15. new 操作符的四个步骤12var Fn = function() &#123;&#125;var fn = new Fn() 创建一个空对象 1var obj = new Object() 设置obj的原型，将obj的原型指向Fn的原型链 1obj.__proto__ = Fn.prototype 将Fn中的this指向obj,并执行Fn 1var result = Fn.call(obj) 判断Fn的返回值类型。如果是引用类型，则返回这个引用类型的对象；如果是值类型，则返回obj` 12345if (typeof result == 'object') &#123; // 引用类型 fn = result&#125; else &#123; // 值类型 fn = obj&#125; 16. 构造函数实现继承的几种方式1234567function Animal () &#123; this.species = '动物'&#125;function Cat (name, color) &#123; this.name = name this.color = color&#125; 使猫继承动物： call apply 12345678function Cat (name, color) &#123; Animal.apply(this, arguments) this.name = name this.color = color&#125;var cat1 = new Cat('name1', 'color1')alert(cat1.species) // 动物 prototype（其一） 12345678function Cat (name, color) &#123; Animal.apply(this, arguments) this.name = name this.color = color&#125;var cat1 = new Cat('name1', 'color1')alert(cat1.species) // 动物 prototype（其二） 12345678function Animal () &#123;&#125;Animal.prototype.species = '动物'Cat.prototype = Animal.prototypeCat.prototype.constructor = Catvar cat3 = new Cat('name3', 'color3')alert(cat3.species) // 动物 利用空对象作为中介 上面那种方法的缺点：Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。 1234var Fn = function () &#123;&#125;Fn.prototype = Animal.prototypeCat.prototype = new Fn()Cat.prototype.construvtor = Cat 将其封装成一个函数 12345678910function extend (Child, Parent) &#123; var Fn = function () &#123;&#125; Fn.prototype = Parent.prototype Child.prototype = new Fn() Child.prototype.constructor = Child&#125;extend(Cat, Animal)var cat4 = new Cat('name4', 'color4')alert(cat4.species) // 动物 拷贝继承 123456789101112131415function Animal () &#123;&#125;Animal.species = '动物'function extend2 () &#123; var C = Child.prototype var P = Parent.prototype for (var i in P) &#123; C[i] = P[i] &#125;&#125;extend2(Cat, Animal)var cat5 = new Cat('name5', 'color5')alert(cat5.species) // 动物 17. 非构造函数的继承123456var Chinese = &#123; nation: '中国'&#125;var Doctor = &#123; career: '医生'&#125; 浅拷贝 123456789101112function shallowCopy (Parent) &#123; var Child = &#123;&#125; for (var i in Parent) &#123; Child[i] = Parent[i] &#125; return Child&#125;var doctor1 = shallowCopy(Chinese)alert(doctor1.nation) // 中国 深拷贝 1234567891011121314151617function deepCopy (Child, Parent) &#123; var Child = Child || &#123;&#125; for (var i in Parent) &#123; if (typeof Parent[i] == 'object') &#123; Child[i] = (Parent[i].constructor === Array) ? [] : &#123;&#125; deepCopy(Child[i], Parent[i]) &#125; else &#123; Child[i] = Parent[i] &#125; &#125; return Child&#125;var doctor2 = deepCopy(Doctor, Chinese)alert(doctor.nation) // 中国 18. 参考链接","comments":true,"tags":[{"name":"dairy","slug":"dairy","permalink":"https://JnathanCoder.github.io/tags/dairy/"}]},{"title":"forEach遍历中断","date":"2019-05-22T09:28:36.000Z","path":"2019/05/22/forEach-interrupt/","text":"123456789101112131415try &#123; [22, 34, 20, 36, 98].forEach( (value, index, arr) =&gt; &#123; if (value === 20) &#123; console.log('遇到20能够退出循环吗？') throw Error('自定义异常提示语') return // return并不能中断循环，这里可写可不写 &#125; else console.log('当前遍历值：', value) &#125;)&#125; catch(err) &#123; console.log(err.message)&#125;// 22// 34// 遇到20能够退出循环吗？// 自定义异常提示语","comments":true,"tags":[]},{"title":"使用 void 0 代替 undefined","date":"2019-05-22T09:02:31.000Z","path":"2019/05/22/void-0/","text":"What…1void 0 === undefined // true Why？ 防止undefined被重写 在ES5之前，window下的undefined是可以被重写的，于是导致了某些极端情况下使用undefined会出现一定的差错。 所以，用void 0是为了防止undefined被重写而出现判断不准确的情况。 事实上，void的返回值都是undefined。ES5之后的标准中，规定了全局变量下的undefined值为只读，不可改写的，但是局部变量中依然可以对之进行改写。补充一下：非严格模式下，undefined是可以重写的，严格模式则不能重写。 节省字节 void 0代替undefined节省3个字节，类似的还有以下用法： 1234567891011121314151617181920212223242526272829303132// 取整操作parseInt(a,10) // BeforeMath.floor(a) // Beforea&gt;&gt;0 // Before~~a // Aftera|0 // After// 四舍五入操作Math.round(a) // Beforea+.5|0 // After// 内置值undefined // Beforevoid 0 // After, 快0[0] // After, 略慢// 内置值Infinity1/0// 布尔值短写法true; // Beforefalse // Before!1 // After!0; // After// 获取上下文对象var global = (function () &#123; return this || (0, eval)('this')&#125;())// (0, eval)('this') 等价于 eval('this') 正常情况下可以直接使用 eval()// 部分低版本IE下，不可以直接运行eval()。","comments":true,"tags":[]},{"title":"this + bind + call + apply","date":"2019-05-21T07:05:59.000Z","path":"2019/05/21/this/","text":"this的指向 this的指向总结起来就是this永远指向最后调用它的那个对象 例1： 123456789var name = 'global'function test() &#123; var name = 'cherry' console.log(this) console.log(this.name)&#125;test()// window// global 调用 test 方法的地方是 test() ，前面没有调用的对象即为 window （严格模式下为 undefined ），相当于 window.test() 。 例2： 123456789var name = 'global'var obj = &#123; name: 'cherry', fn: function () &#123; console.log(this.name) &#125;&#125;obj.fn() // cherrywindow.obj.fn() // cherry obj.fn() 取用的是 obj 对象 里面的 name 值， window.obj.fn() 里面，最后调用的是 obj 对象，所以也是 cherry 。补充：假如将 obj 对象中 name 属性的定义注释掉，那么 obj.fn() 将会打印出 undefined ，因为只会看最近的调用 obj 对象 ，当没有定义时，不会继续向上一个对象 window 寻找 name 属性。 例3： 123456789var name = 'global'var obj = &#123; name: 'cherry', fn: function () &#123; console.log(this.name) &#125;&#125;var temp = obj.fn()temp() // global 再来看一遍：this 永远指向 最后调用 它的那个对象。 obj.fn() 赋值给 temp 时，并没有进行赋值！最后 temp() 调用的时候是 window.temp() ，所以打印 global 。 例4： 123456789var name = 'global'function fn () &#123; var name = 'cherry' innerFn() function innerFn () &#123; console.log(this.name) &#125;&#125;fn() // global 例5： 1234567891011121314151617181920function Func () &#123; this.name = 'cherry'&#125;var fn = new Func()console.log(fn.name) // cherry// =================================function Func2 () &#123; this.name = 'cherry' return &#123;name: 'apple'&#125; // 返回一个对象 如果name改为name2，fn2.name为undefined&#125;function Func3 () &#123; this.name = 'cherry' return true // 返回true，非对象（false, 124, 'abc'都可）&#125;var fn2 = new Func2()console.log(fn2.name) // applevar fn3 = new Func3()console.log(fn3.name) // cherry 当我们通过 new 关键字构造一个实例对象的过程中，构造函数中的 this 一般情况下指向我们构造出来的实例化对象，因此在构造过程中 this.name = &#39;cherry&#39; 这句代码就相当于给实例对象 fn 创建了一个 name 属性并赋值 cherry 。特别的，当构造函数中的 this 遇到 return 的情况。当构造函数中返回值是一个对象时，this 指向的就是返回的那个对象；如果返回值不是对象时，this 指向的就是构造函数（这里是 Func3 ）。 改变this的指向例6： 12345678910111213var name = 'global'var obj = &#123; name: 'cherry', fn1: function () &#123; console.log(this.name) &#125;, fn2: function () &#123; setTimeout(function () &#123; this.fn1() &#125;, 1000) &#125;&#125;obj.fn2() // this.fn1 is not a function setTimeout() 即为 window.setTimeout() ，最后调用的对象是 window，而 window 中并没有方法 fn1() ，故而报错。 我们通常使用以下几种方法改变this的指向问题： var _this = this 12345678// ...fn2: function () &#123; var _this = this setTimeout(function () &#123; _this.fn1() // cherry &#125;, 1000)&#125;// ... 箭头函数 1234567// ...fn2: function () &#123; setTimeout( () =&gt; &#123; this.fn1() // cherry &#125;, 1000)&#125;// ... bind 1234567// ...fn2: function () &#123; setTimeout(function () &#123; this.fn1() // cherry &#125;. bind(obj)(), 1000) // 这里的obj也可以换成this this指向obj&#125;// ... call 1234567// ...fn2: function () &#123; setTimeout(function () &#123; this.fn1() // cherry &#125;.call(obj), 1000) // 这里的obj也可以换成this this指向obj&#125;// ... apply 1234567// ...fn2: function () &#123; setTimeout(function () &#123; this.fn1() // cherry &#125;.apply(obj), 1000) // 这里的obj也可以换成this this指向obj&#125;// ... bind介绍 bind() 方法创建一个 新的函数， 当被调用时，将其 this 关键字设置为提供的值。在调用新函数时，在任何提供之前提供一个给定的参数序列。 例7： 123456789var obj = &#123; func: function (a, b) &#123; console.log('乘积： ' + a * b) &#125;&#125;obj.func.bind(obj, 2, 8) // f (a, b) &#123; // console.log('乘积： ' + a * b) // &#125;obj.func.bind(obj, 2, 8)() // 乘积： 16 因为 bind 只会重新赋予 this，并不会自动执行，需要手动执行，固有第二个的结果。 call介绍 functionObj.call(thisArg[, args1, args2, args3, …]) thisArg -&gt; 函数在运行时指定的 this 。当为 null 或者 undefined 时，自动指向 window 。当为string 、number 、boolean 类型的时候，this 指向各自的包装对象。 123456789101112function test () &#123; console.log('this: ' + this)&#125;test.call(null) // windowtest.call(undefined) // windowtest.call('abcd') // Stringtest.call(128) // Numbertest.call(false) // Boolean// apply() 的结果与 call() 一致test.apply(null) // window// ... 例8： 1234567var obj = &#123; name: 'hello', func: function (a, b) &#123; console.log('乘积： ' + a * b) &#125;&#125;obj.func.call(obj, 2, 5) // 乘积： 10 apply介绍 functionObj.apply(thisArg[, argsArr]) apply 的语法和 call 的语法类似，区别在于 apply 的参数列表是以 数组 或者 类数组 形式传入。 例9： 1234567var obj = &#123; name: 'hello', func: function (a, b) &#123; console.log('乘积： ' + a * b) &#125;&#125;obj.func.apply(obj, [2, 6]) // 乘积： 12 call、apply常见用法 将类数组 ArrayLike 转换成数组 Array 12345678910111213141516var arraylike = &#123;'1': 'hello', '2': 'world', '3': 'balabala', length: 4&#125;function ArrTransfer () &#123; // return [].slice.call(arguments) return Array.prototype.slice.call(arguments) // return [].splice.call(arguments, 0) // return Array.prototype.splice.call(arguments, 0) // return Array.from(arguments)&#125;var list = ArrTransfer(arrayLike) // [&#123;'1': 'hello', '2': 'world', '3': 'balabala', length: 3&#125;]Array.prototype.slice.call(arrayLike).forEach( (elem, index) =&gt; &#123; console.log(elem, index) // hello 1 // world 2 // balabala 3&#125;) 求最大最小值 123var arr = [21, 2, 35, 9, 23, 16, 29]Math.max.apply(Math, arr) // 35Math.min.apply(Math, arr) // 2 Useful Link 全文参考自掘金文章","comments":true,"tags":[{"name":"this","slug":"this","permalink":"https://JnathanCoder.github.io/tags/this/"},{"name":"作用域","slug":"作用域","permalink":"https://JnathanCoder.github.io/tags/作用域/"}]},{"title":"企业微信中超链接地址跳转","date":"2019-05-21T03:04:11.000Z","path":"2019/05/21/wxwork-link-unRirect/","text":"问题描述：在ios(版本号未测试)企业微信(版本号未测试)中，并且超链接target属性是_blank时，点击超链接不能正常跳转，当前页面自动刷新一次。而在ios微信浏览器以及android中未复现。 解决办法 直接修改target属性值为非_blank即可； 如果是从富文本编辑器中出来的html内容，可以借助js进行处理。示意代码如下： 1234let oAList = document.querySelectorAll('a')Array.from(oAList).forEach( (aLink, index) =&gt; &#123; aLink.getAttribute('target') === '_blank' ? aLink.setAttribute('target', '_self') : null // 设置成null也可&#125;)","comments":true,"tags":[{"name":"企微","slug":"企微","permalink":"https://JnathanCoder.github.io/tags/企微/"},{"name":"超链接","slug":"超链接","permalink":"https://JnathanCoder.github.io/tags/超链接/"}]},{"title":"CSS文本超出容器宽度使用省略号代替（不考虑js方法）","date":"2019-03-31T16:00:00.000Z","path":"2019/04/01/text-overflow-ellipsis/","text":"方法一 ：常规方法（适用于webkit内核浏览器）12&lt;div class=\"container text-ellipsis\"&gt;单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号单行文字超出省略号&lt;/div&gt;&lt;div class=\"container text-ellipsis-multi\"&gt;多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号&lt;/div&gt; 1234567891011121314151617181920.container &#123; display: inline-block; width: 333px; height: 60px; font-size: 16px; border: 1px solid #00bebe;&#125;.text-ellipsis &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;.text-ellipsis-multi &#123; line-height: 20px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; // 控制显示的行数 -webkit-box-orient: vertical;&#125; 在webkit浏览器中的表现： 方法二：利用伪类+float（适用于大部分浏览器）原理讲解参考这里 123&lt;div class=\"wrap\"&gt; &lt;div class=\"text\"&gt;多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号多行文字超出省略号&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930.wrap &#123; background: #099; max-height: 40px; line-height: 20px; overflow: hidden;&#125;.wrap:before &#123; float: left; content: ''; width: 20px; height: 40px;&#125;.wrap .text &#123; float: right; width: 100%; margin-left: -20px; word-break: break-all;&#125;.wrap:after &#123; float: right; content: '...'; width: 20px; height: 20px; &lt;!-- 下方三行代码 调整省略号位置 --&gt; &lt;!-- 未超出时，省略号在wrap外面，被隐藏 --&gt; position: relative; left: 100%; transform: translate(-100%, -100%);&#125; 在非webkit内核浏览器中的表现： 可以看到效果还是不那么尽人意，可以在此基础上再根据实际情况修改相应代码，比如...用渐变色代替现在的白色，会显得平滑。另外，也可以搭配js进一步处理，可以参考这里。 也可使用封装好的 vue组件 。 更详细的文章参考这里。","comments":true,"tags":[{"name":"ellipsis","slug":"ellipsis","permalink":"https://JnathanCoder.github.io/tags/ellipsis/"},{"name":"换行","slug":"换行","permalink":"https://JnathanCoder.github.io/tags/换行/"},{"name":"省略号","slug":"省略号","permalink":"https://JnathanCoder.github.io/tags/省略号/"}]}]